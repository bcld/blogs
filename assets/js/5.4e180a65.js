(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{447:function(v,_,e){v.exports=e.p+"assets/img/Snipaste_2022-11-21_21-22-01.b89eef74.png"},448:function(v,_,e){v.exports=e.p+"assets/img/Snipaste_2022-11-22_18-15-32.863ae171.png"},449:function(v,_,e){v.exports=e.p+"assets/img/Snipaste_2022-11-29_15-51-00.c60dd55c.png"},450:function(v,_,e){v.exports=e.p+"assets/img/SpringBeanLife.33c1bfed.jpg"},451:function(v,_,e){v.exports=e.p+"assets/img/Snipaste_2022-11-21_11-22-50.567bfd91.png"},452:function(v,_,e){v.exports=e.p+"assets/img/Snipaste_2022-11-30_16-40-56.ac97db7f.png"},453:function(v,_,e){v.exports=e.p+"assets/img/Snipaste_2022-11-21_16-36-49.26d1fafb.png"},497:function(v,_,e){"use strict";e.r(_);var a=e(33),l=Object(a.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"面试常见问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试常见问题"}},[v._v("#")]),v._v(" 面试常见问题")]),v._v(" "),a("h2",{attrs:{id:"集合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#集合"}},[v._v("#")]),v._v(" 集合")]),v._v(" "),a("p",[a("strong",[v._v("如何选取集合结构?")])]),v._v(" "),a("ul",[a("li",[v._v("如果我们需要根据键值来获取元素值，就可以选用Map接口下的集合。需要排序就选用TreeMap，不需要排序就选用HashMap，需要保证线程安全就选用ConcurrentHashMap;")]),v._v(" "),a("li",[v._v("如果我们只需要存放元素值，就选择实现Collection接口的集合。需要保证元素唯一时选择Set接口下的集合，比如TreeSet或者是HashSet，不需要就选用List接口下的集合，比如ArrayList或者LinkedList。")])]),v._v(" "),a("p",[a("strong",[v._v("说说List、Set、Queue和Map四者的区别、")])]),v._v(" "),a("ul",[a("li",[v._v("List 存储的元素是有序的、可重复的")]),v._v(" "),a("li",[v._v("Set 存储的元素是无序的、不可重复的")]),v._v(" "),a("li",[v._v("Queue 按照特定的排队规则来排序，存储的元素是有序的、可重复的")]),v._v(" "),a("li",[v._v("Map 使用key-value来进行存储数据，key是无序的、不可重复的，value是无序的、可重复的")])]),v._v(" "),a("p",[a("strong",[v._v("底层的数据结构")])]),v._v(" "),a("ul",[a("li",[v._v("ArrayList Object[]数组，线程不安全，节省空间，每次扩展1.5倍，根据下标访问快，根据内容查找慢")]),v._v(" "),a("li",[v._v("Vector Object[]数组，线程安全，占空间，允许手动设置增长因子")]),v._v(" "),a("li",[v._v("LinkedList 双向链表（jdk1.6之前是循环链表，1.7取消了循环），插入删除快")]),v._v(" "),a("li",[v._v("HashSet（无序、唯一） 底层采用HashMap来保存元素")]),v._v(" "),a("li",[v._v("TreeSet（有序、唯一） 底层采用红黑树（自平衡的二叉排序树）实现")]),v._v(" "),a("li",[a("s",[v._v("ArrayQueue Object[]数组 + 双指针")])]),v._v(" "),a("li",[a("s",[v._v("PriorityQueue Object[]数组来实现二叉堆")])]),v._v(" "),a("li",[v._v("HashMap jdk1.8之前由数组+链表组成，数组是HashMap的主体，而链表主要是为了解决哈希冲突。jdk1.8之后引入了红黑树。当链表长度大于等于8且数组长度大于等于64，链表就会转化为红黑树。如果只满足一个条件，那么会优先选择数组扩容。")]),v._v(" "),a("li",[v._v("TreeMap 红黑树（自平衡的二叉排序树），底层是基于TreeSet实现的，有序")])]),v._v(" "),a("p",[v._v("** hashMap hashTable concurrentHashMap **")]),v._v(" "),a("ul",[a("li",[v._v("hashMap多线程环境下扩容，会存在条件竞争，节点相互引用容易造成死循环，key/value支持为null")]),v._v(" "),a("li",[v._v("rehash是一个比较耗时的操作")]),v._v(" "),a("li",[v._v("hashTable涉及到修改的方法都通过synchronized修饰，所以线程安全但性能比较差")]),v._v(" "),a("li",[v._v("concurrentHashMap：早期通过分段锁Segment来实现（拆分数组加锁），现在通过CAS+synchronized使锁细化\n"),a("ul",[a("li",[v._v("使用无锁操作cas插入头节点，失败则循环重试")]),v._v(" "),a("li",[v._v("如果头节点存在，则尝试获取同步锁（synchronized），获取成功进行操作")])])])]),v._v(" "),a("p",[a("strong",[v._v("arrayList如何扩容")])]),v._v(" "),a("ul",[a("li",[v._v("如果没有指定入参，为空数组，添加第一个元素时容器(elementData)大小默认为10")]),v._v(" "),a("li",[v._v("如果构造函数入参有size值，则在size值基础上扩容")]),v._v(" "),a("li",[v._v("容器填满后会触发扩容，调用grow()方法，创建新的数组拷贝元素，数组大小为原来1.5倍（固定，右移运算符一位），赋值给容器（elementData），添加新元素")]),v._v(" "),a("li",[v._v("内部容器elementData(transient修饰不序列化)地址会变，但是list数组不会。")])]),v._v(" "),a("h2",{attrs:{id:"多线程实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多线程实现"}},[v._v("#")]),v._v(" 多线程实现")]),v._v(" "),a("ol",[a("li",[a("p",[v._v("继承Thread类")])]),v._v(" "),a("li",[a("p",[v._v("实现runnable接口")])]),v._v(" "),a("li",[a("p",[v._v("实现Callable接口（run方法有返回值，且允许异常往外抛）")])]),v._v(" "),a("li",[a("p",[v._v("线程池")]),v._v(" "),a("ol",[a("li",[v._v("核心线程数 corePoolSize："),a("em",[v._v("除非配置了preStartAlltCoreThread,否则无任务时不会创建线程，新提交任务将直接创建新线程执行。")])]),v._v(" "),a("li",[v._v("最大线程数 maxPoolSize："),a("em",[v._v("当队列满了会创建超过核心线程数据的线程，会把任务丢入队列中，只有队列满了才会新增线程，largestPoolSize，曾经最大线程数，因为线程池创建后，可以调用setMaximumPoolSize()改变值")])]),v._v(" "),a("li",[v._v("非核心线程闲置超时时长 keepAliveTime："),a("em",[v._v("只有当线程池中线程大于corePoolSize时，才会起作用。如果设置了allCoreThreadTimeOut(boolean)方法，则一直起作用知道线程数为0")])]),v._v(" "),a("li",[v._v("timeUnit 时间单位")]),v._v(" "),a("li",[v._v("workQueue："),a("em",[v._v("阻塞队列，用来存放等待的任务")])]),v._v(" "),a("li",[v._v("ThreadFactory ："),a("em",[v._v("线程工厂，创建线程的方式")])]),v._v(" "),a("li",[v._v("handler："),a("em",[v._v("拒绝处理任务时的策略，饱和策略")]),v._v(" "),a("ul",[a("li",[v._v("abortPolicy:直接抛出异常（默认）")]),v._v(" "),a("li",[v._v("CallerRunsPolicy: 用调用者所在线程执行任务")]),v._v(" "),a("li",[v._v("DiscardOldestPolicy：丢弃队列中最早进入队列的任务，并把当前任务加入队列中")]),v._v(" "),a("li",[v._v("DiscardPolicy：直接丢弃任务")]),v._v(" "),a("li",[v._v("实现RejectExecutionHandler接口的自定义handler")])])])])])]),v._v(" "),a("p",[a("img",{attrs:{src:e(447),alt:""}})]),v._v(" "),a("p",[a("strong",[v._v("ThreadPoolExecutor类中几个常用重要的方法")])]),v._v(" "),a("ul",[a("li",[v._v("void execute(Runnable task)")]),v._v(" "),a("li",[v._v("Future "),a("code",[v._v("<T>")]),v._v(" submit(Callable "),a("code",[v._v("<T>")]),v._v(" task) 可以获取返回结果，提交任务之后，不等待。主线程准备一个接收结果的对象，通过Future获取结果，等待结果过程阻塞。")]),v._v(" "),a("li",[v._v("void shutdown()")]),v._v(" "),a("li",[v._v("List "),a("code",[v._v("<Runnable>")]),v._v("shutdownNow()")])]),v._v(" "),a("p",[a("a",{attrs:{href:"https://www.jianshu.com/p/210eab345423",target:"_blank",rel:"noopener noreferrer"}},[v._v("线程池，这一篇或许就够了 - 简书 (jianshu.com)"),a("OutboundLink")],1)]),v._v(" "),a("blockquote",[a("p",[v._v("sleep只会让出cpu不会导致锁行为改变（Thread类的方法）可以在任何方法使用，wait()不仅让出cpu还释放已经占有的同步资源锁，object的方法，只能在synchronized代码块中使用")])]),v._v(" "),a("p",[a("strong",[v._v("notify和notifyAll的区别")]),v._v("\nnotifyAll会让所有处于等待池的线程全部进入锁池中去竞争获取锁，notify只会随机选中一个线程进入锁池去竞争")]),v._v(" "),a("p",[a("strong",[v._v("线程的状态或生命周期")]),v._v(" "),a("img",{attrs:{src:e(448),alt:""}})]),v._v(" "),a("ol",[a("li",[v._v("新建，new一个线程（单向）")]),v._v(" "),a("li",[v._v("可运行状态，start()后进入可运行状态，竞争cpu资源(时间片)")])]),v._v(" "),a("ul",[a("li",[v._v("Thread.yield()让出资源")]),v._v(" "),a("li",[v._v("时间片用完")]),v._v(" "),a("li",[v._v("阻塞完成")])]),v._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[v._v("运行状态，获取资源成功(获取锁)")]),v._v(" "),a("li",[v._v("死亡状态（单向）")])]),v._v(" "),a("ul",[a("li",[v._v("run()方法结束")]),v._v(" "),a("li",[v._v("main()方法结束")]),v._v(" "),a("li",[v._v("抛出异常")])]),v._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[v._v("阻塞状态（不释放锁）")])]),v._v(" "),a("ul",[a("li",[v._v("等待用户操作")]),v._v(" "),a("li",[v._v("Thread.sleep()")]),v._v(" "),a("li",[v._v("otherTread.join()")])]),v._v(" "),a("h2",{attrs:{id:"spring"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring"}},[v._v("#")]),v._v(" Spring")]),v._v(" "),a("blockquote",[a("p",[v._v("spring core初期应用是springMvc，主要提高单体应用开发效率（容器）\nspring boot 是懒人整合包，整合了很多非功能特性。\nspring clound 是微服务架构的落地，打造开箱即用（生态）\n"),a("em",[v._v("Spring Boot内嵌了如Tomcat，Jetty和Undertow这样的容器，也就是说可以直接跑起来，用不着再做部署工作了")])])]),v._v(" "),a("p",[a("strong",[v._v("springCloud的组件/调用顺序")])]),v._v(" "),a("ul",[a("li",[v._v("zuul:网关，一般nginx调用zuul")]),v._v(" "),a("li",[v._v("feign：封装http的restful风格调用")]),v._v(" "),a("li",[v._v("ribbon：负载均衡，通过轮询算法把请求均匀分配在多台服务器上")]),v._v(" "),a("li",[v._v("hystrix：隔离熔断，很多小的线程池，提供降级处理，挂掉的服务直接返回失败不阻塞")]),v._v(" "),a("li",[v._v("eureka：服务注册和发现")])]),v._v(" "),a("blockquote",[a("p",[v._v("流程\n客户端请求先到达nginx，（因为zuul的性能一般（用它主要是因为它属于SpringCloud家族，“有背景”），所以让nginx作为客户端的入口，即负责对外暴露端口）\n然后nginx再将该客户端请求发到某一个zuul组件上面（zuul性能一般，所以就多来几个，通常是一个zuul集群），\n然后zuul再将请求转发到指定的服务模块上面，\n服务之间通过Feign进行相互的调用，\n请求在处理的过程中可能会出现问题，出现问题怎么办呢，用Hystrix来做服务降级处理（即，直接返回一个错误信息给zuul的errorfilter错误过滤器），\n服务最后处理完请求之后，返回响应结果给zuul的postfilters后置过滤器，由zuul的postfilters后置过滤器将处理结果再响应给用户。\n"),a("img",{attrs:{src:e(449),alt:""}})])]),v._v(" "),a("p",[a("strong",[v._v("Spring 框架中都用到了哪些设计模式？")])]),v._v(" "),a("ol",[a("li",[v._v("工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；")]),v._v(" "),a("li",[v._v("单例模式：Bean默认为单例模式。")]),v._v(" "),a("li",[v._v("代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；")]),v._v(" "),a("li",[v._v("模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。")]),v._v(" "),a("li",[v._v("观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。")])]),v._v(" "),a("p",[a("strong",[v._v("BeanFactory 和 ApplicationContext有什么区别？")])]),v._v(" "),a("ul",[a("li",[v._v("BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义")]),v._v(" "),a("li",[v._v("ApplicationContext接口作为BeanFactory的子接口")]),v._v(" "),a("li",[v._v("BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化，ApplicationContext则启动加载（占内存）。")])]),v._v(" "),a("p",[a("strong",[v._v("Spring框架中的单例bean是线程安全的吗？")])]),v._v(" "),a("ol",[a("li",[v._v("不是，Spring框架中的单例bean不是线程安全的。")]),v._v(" "),a("li",[v._v("spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。")]),v._v(" "),a("li",[v._v("实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。")]),v._v(" "),a("li",[v._v("还可以通过threadlocal实现线程安全（为每一个线程提供一个变量副本）")])]),v._v(" "),a("p",[a("strong",[v._v("什么是Spring的内部bean？什么是Spring inner beans？")])]),v._v(" "),a("ul",[a("li",[v._v("一个bean仅当作为另一个bean的属性时，会被声明为一个内部bean，可以setter注入属性，或者构造方法注入构造参数实现")])]),v._v(" "),a("p",[a("strong",[v._v("什么是AOP，spring中AOP的实现")])]),v._v(" "),a("ul",[a("li",[v._v("AOP(Aspect-Oriented Programming)，一般称为面向切面编程")]),v._v(" "),a("li",[v._v("AOP实现的关键在于 代理模式，AOP代理主要分为静态代理（编译阶段）和动态代理（运行阶段）。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。")]),v._v(" "),a("li",[v._v("Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理\n"),a("ul",[a("li",[v._v("JDK动态代理只提供接口的代理")]),v._v(" "),a("li",[v._v("CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。")])])]),v._v(" "),a("li",[v._v("aop是ioc整体流程中的一个扩展点")])]),v._v(" "),a("p",[a("strong",[v._v("aop怎么实现")])]),v._v(" "),a("ul",[a("li",[v._v("静态AOP：在编译期，切面直接以字节码形式编译到目标字节码中")]),v._v(" "),a("li",[v._v("动态AOP（JDK）：目标类加载后，为接口动态生成代理类，将切面植入到代理类中，在运行时动态织入AOP，使用反射执行织入逻辑，依赖reflect包下的InvocationHandler接口和Proxy类")]),v._v(" "),a("li",[v._v("动态AOP(cglib)：通过字节码生成工具asm，在运行期间加载目标字节码后，生成目标类的子类，然后将切面逻辑加入子类中")])]),v._v(" "),a("p",[a("strong",[v._v("spring bean的生命周期(6个阶段，定义不重要，重要的是顺序和做了什么)")])]),v._v(" "),a("blockquote",[a("p",[a("a",{attrs:{href:"https://juejin.cn/post/6844904065457979405",target:"_blank",rel:"noopener noreferrer"}},[v._v("如何记忆 Spring Bean 的生命周期 - 掘金 (juejin.cn)"),a("OutboundLink")],1)]),v._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/qq_23473123/article/details/76610052#:~:text=%E7%9B%AE%E7%9A%84",target:"_blank",rel:"noopener noreferrer"}},[v._v("spring 生命周期最详解_qq_23473123的博客-CSDN博客_spring的生命周期"),a("OutboundLink")],1)])]),v._v(" "),a("ul",[a("li",[v._v("实例化对象（instantiation）\n"),a("ul",[a("li",[v._v("在堆空间中申请空间，属性一般是默认值，即反射创建对象的过程，关键方法createBeanInstance")])])]),v._v(" "),a("li",[v._v("自定义属性赋值（populateBean）\n"),a("ul",[a("li",[v._v("populateBean() set方法完成赋值操作")])])]),v._v(" "),a("li",[v._v("初始化（实现aware接口、beanPostProcessedBeforeInitialization、执行init-method方法（检测是否实现initializingBean接口，执行afterPropertiesSet()方法)）、beanPostProcessedAfterInitialization）\n"),a("ul",[a("li",[v._v("检查aware接口并设置相关依赖（springBean按照使用者可以分为自定义对象和容器对象，用于标志，规范统一注入容器对象属性），关键方法invokeAwareMethods")])])]),v._v(" "),a("li",[v._v("准备销毁（注册destruction回调接口）")]),v._v(" "),a("li",[v._v("使用")]),v._v(" "),a("li",[v._v("销毁（实现disposableBean接口、destroy()方法）\n"),a("img",{attrs:{src:e(450),alt:""}})])]),v._v(" "),a("p",[a("strong",[v._v("beanFactory和FactoryBean的区别")])]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v("BeanFactory是底层接口，规范了标准化对象创建的整体流程，Bean的生命周期是一个完整的标准化过程，相对比很麻烦\nFactoryBean是私人定制，用来自定义创建bean对象的入口，需要实现几个方法isSingleton，getObjectType，getObject\n")])])]),a("p",[a("strong",[v._v("spring如何解决循环依赖")])]),v._v(" "),a("blockquote",[a("p",[v._v("循环依赖即循环引用，2个以上的bean之间互相持有对方，最终形成闭环。\nspring实际通过分开实例化和初始化过程来解决闭环问题。实例化和初始化放在不同容器中")])]),v._v(" "),a("ol",[a("li",[v._v("一级缓存 SingletonObjects ，线程安全，二级缓存 earlySingletonObjects ，三级缓存 singletonFactories")]),v._v(" "),a("li",[v._v("一级缓存最大，三级缓存最少，因为对象放到一级缓存，就会删除三级缓存对应的对象那个，因为遍历查询是从一级往下查，一级存在，三级用不上。")]),v._v(" "),a("li",[v._v("一级缓存放到是初始化完成的bean，二级放的是完成实例化但还没完成初始化的bean，三级放的是lamba表达式，lamda表达式只有执行getObject()方法才真正执行。")]),v._v(" "),a("li",[v._v("一个map结构也能解决循环依赖问题，但操作比较麻烦，需要标志位去区分成品和半成品")]),v._v(" "),a("li",[v._v("是否可以使用两个map能解决循环依赖问题？可以，前提是不需要使用代理对象")])]),v._v(" "),a("blockquote",[a("p",[v._v("操作流程:getBean->doGetBean->createBean->doCreateBean->createBeanInstance->populateBean")])]),v._v(" "),a("p",[a("strong",[v._v("为什么三级缓存之后可以解决带AOP的循环引用？")])]),v._v(" "),a("ol",[a("li",[v._v("程序在调用时无法判断原始对象是否存在代理对象，代理对象的创建是在初始化过程的扩展阶段，而属性赋值是在初始化前置阶段，所以需要在属性赋值的时候替换掉原始对象，通过lambda表达式类似回调的特性，真正调用时才判断返回原对象还是代理对象。")])]),v._v(" "),a("p",[a("strong",[v._v("spring的七种事务传播级别")])]),v._v(" "),a("ol",[a("li",[v._v("Propagation.REQUIRED:默认的传播级别，如果当前上下文存在事务则加入事务中，如果上下文不存在事务，则新建事务执行")]),v._v(" "),a("li",[v._v("Propagation.SUPPORTS:如果上下文存在事务，加入到事务执行，没有则使用非事务方式执行")]),v._v(" "),a("li",[v._v("Propagation.MADATORY:要求上下文必须要有事务，否则抛出异常")]),v._v(" "),a("li",[v._v("Propagation.REQUIRES_NEW:每次都要新建一个事务，同时将上下文事务挂起，当前新建事务执行完成后再恢复上下文事务")]),v._v(" "),a("li",[v._v("Propagation.NOT_SUPPORTED:如果上下文中存在事务，则挂起事务，执行当前逻辑，结束后恢复上下文的事务")]),v._v(" "),a("li",[v._v("Propagation.NEVER:要求上下文不能存在事务，否则抛出异常")]),v._v(" "),a("li",[v._v("Propagation.NESTED:如果上下文存在事务，则嵌套事务执行，否则新建事务执行（父事务回滚，子事务也会跟着回滚，子事务是父事务的一部分，由父事务统一提交）")])]),v._v(" "),a("p",[a("strong",[v._v("spring的自动装配原理")]),v._v("\n整体流程@SpringBootApplication(@EnableAutoConfiguration),自定义实现ImportSelector接口，在getCandidateConfigurations()方法默认加载meta-info/spring.factories文件中的类，加入到spring容器中。")]),v._v(" "),a("h2",{attrs:{id:"sql"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sql"}},[v._v("#")]),v._v(" sql")]),v._v(" "),a("p",[a("strong",[v._v("遇到的索引失效情况，或者慢sql")])]),v._v(" "),a("ol",[a("li",[v._v("两个关联表查询的关联字段有索引，但是索引类型不一致导致不走索引")]),v._v(" "),a("li",[v._v("分页查询，对于limit 20000,100的情况会先把查到的20000 抛掉，可以通过有序的id过滤提高性能")])]),v._v(" "),a("h2",{attrs:{id:"微服务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微服务"}},[v._v("#")]),v._v(" 微服务")]),v._v(" "),a("p",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/111796998",target:"_blank",rel:"noopener noreferrer"}},[v._v("20道你必须要背会的微服务面试题，面试一定会被问到 - 知乎 (zhihu.com)"),a("OutboundLink")],1)]),v._v(" "),a("p",[a("strong",[v._v("分布式系统面临的问题")])]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v("1. 服务雪崩问题，服务相互依赖，牵一发而动全身，处理不好容易引起级联反应。要对故障进行隔离和管理。\n  - 熔断机制，对于熔断服务后续的请求直接返回，快速释放资源。\n  - 隔离模式，对不同类型业务请求使用线程池资源隔离\n  - 限流模式，预防模式，提前对各种请求设置最高QPS,超过阈值直接返回\n")])])]),a("p",[a("strong",[v._v("maven生命周期")])]),v._v(" "),a("ul",[a("li",[v._v("clean：项目清理处理")]),v._v(" "),a("li",[v._v("default/build：项目部署处理\nvalidate->compile->test(单元测试框架测试)->package->verify(检查集成测试的结果)->install(打包到本地仓库)->deploy(拷贝到远程仓库)")]),v._v(" "),a("li",[v._v("site：项目站点文档创建")])]),v._v(" "),a("p",[a("strong",[v._v("JVM内存模型")]),v._v(" "),a("img",{attrs:{src:e(451),alt:""}}),v._v("\n线程私有：")]),v._v(" "),a("ul",[a("li",[v._v("程序计数器(逻辑计数器，线程独有，JVM通过读取计数器的值决定下一条需要执行的字节码指令，不会有内存泄漏问题)")]),v._v(" "),a("li",[v._v("java虚拟机栈，当前线程的所有栈帧，栈帧存放局部变量表（方法执行过程中的所有变量）和操作栈（一个存放的容器，入栈、出栈，复制、交换）,调用完成会自动释放栈内存\n"),a("img",{attrs:{src:e(452),alt:""}}),v._v(" "),a("ul",[a("li",[v._v("递归过深，会出现java.lang.StackOverflowError异常")]),v._v(" "),a("li",[v._v("虚拟机栈过多还会引发java.lang.OutOfMemoryError")])])]),v._v(" "),a("li",[v._v("本地方法栈：与虚拟机栈相似，主要作用于标注了native的方法")])]),v._v(" "),a("p",[v._v("线程共享：")]),v._v(" "),a("ul",[a("li",[v._v("metaSpace和PermGen的区别：前者只是后者更加合理的划分，字符串常量池存在堆中，用的是本地内存而非jvm内存，其他大同小异。")]),v._v(" "),a("li",[v._v("java堆（Heap）：存放所有对象实例，GC管理的主要区域")])]),v._v(" "),a("p",[a("strong",[v._v("java三大性能调优参数 -Xmx -Xms -Xss")])]),v._v(" "),a("ul",[a("li",[v._v("-Xss：规定每个线程的虚拟机栈大小")]),v._v(" "),a("li",[v._v("-Xms: java堆初始值")]),v._v(" "),a("li",[v._v("-Xmx: java堆最大值")])]),v._v(" "),a("p",[a("strong",[v._v("堆和栈的区别")]),v._v("\njava内存分配策略")]),v._v(" "),a("ul",[a("li",[v._v("静态存储：编译时确定存储空间的需求")]),v._v(" "),a("li",[v._v("栈式存储：编译时未知，但是运行时模块入口前确定")]),v._v(" "),a("li",[v._v("堆式存储：编译和运行时都无法确定，动态分配")])]),v._v(" "),a("ol",[a("li",[v._v("分配方式：栈支持静态和动态分配，堆仅支持动态分配")]),v._v(" "),a("li",[v._v("释放方式：栈自动释放，堆需要GC释放，空间而言栈比较少，碎片也比较少")]),v._v(" "),a("li",[v._v("储存内容：创建的数组和对象实例都会被保存在堆中，栈保存的是某个变量的在堆中的首地址")])]),v._v(" "),a("p",[a("strong",[v._v("不同版本intern()--返回字符串对象的规范化表示形式,一定取自具有唯一字符串的池。方法区别")]),v._v("\njdk6只会往常量池添加字符串返回引用，而1.8还会往常量池中添加堆的引用")]),v._v(" "),a("p",[a("strong",[v._v("判断为java垃圾的标准")])]),v._v(" "),a("ul",[a("li",[v._v("引用计数算法：每个对象实例都有一个引用计数器，如果被引用则+1，完成则-1, 任何引用计数为0的对象实例可以被当成垃圾收集\n"),a("ul",[a("li",[v._v("优点，效率高")]),v._v(" "),a("li",[v._v("缺点，无法检测出循环引用的情况，导致内存泄漏")])])]),v._v(" "),a("li",[v._v("可达性分析算法：判断对象的引用链是否可达决定是否可以回收")])]),v._v(" "),a("p",[a("strong",[v._v("垃圾回收算法")])]),v._v(" "),a("ol",[a("li",[v._v("复制算法：存活的对象复制到一个地方，解决碎片化问题，适用于对象存活率低的场景（年轻代）")]),v._v(" "),a("li",[v._v("标记-清除算法（mark and sweep），清除所有被标记为不可达对象")])]),v._v(" "),a("ul",[a("li",[v._v("缺点：碎片化，内存不连续")])]),v._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[v._v("标记-整理算法：根集合扫描，对存活对象进行标记，移动清楚所有存活对象，且按照内存地址次序依次排列，将末端内存地址以后的内存全部回收，适合于存活率高的场景（老年代）")]),v._v(" "),a("li",[v._v("分代收集算法--Generational Collector（组合拳）")])]),v._v(" "),a("ul",[a("li",[v._v("Minor GC--年轻代")]),v._v(" "),a("li",[v._v("full GC--老年代")])]),v._v(" "),a("blockquote",[a("p",[v._v("年轻代 分为eden区 和survival区 ，一般是8：1，survival又有from 和 to，每次minor gc会清空Eden区，survival区使用复制算法挪动和计数，超过一定次数就会放入老年代,较大的对象装不下也会直接进入老年代\n"),a("img",{attrs:{src:e(453),alt:""}})])]),v._v(" "),a("p",[a("strong",[v._v("触发full gc的场景")])]),v._v(" "),a("blockquote",[a("p",[v._v("full gc会阻塞其他线程，其他线程会进入最新的安全点，停顿下来，否则full gc会等到所有线程进入安全点才开始，所以安全点不能太多也不能太少")])]),v._v(" "),a("ol",[a("li",[v._v("老年代空间不足（jdk 7 以下永久代不足）")]),v._v(" "),a("li",[v._v("Minor gc时，计算出晋升到老年代的平均大小大于老年代的剩余空间")]),v._v(" "),a("li",[v._v("程序调用System.gc(),提醒并非强制")])]),v._v(" "),a("p",[a("strong",[v._v("java中强引用，弱引用，软引用，虚引用有什么用")])]),v._v(" "),a("ol",[a("li",[v._v("强引用，不会被回收")]),v._v(" "),a("li",[v._v("软引用，有用但非必须状态，内存不足时会回收该对象的内存")]),v._v(" "),a("li",[v._v("弱引用，gc时会被回收")]),v._v(" "),a("li",[v._v("虚引用，任何时候都可能被垃圾回收器回收")])]),v._v(" "),a("p",[a("strong",[v._v("如何排查生产问题")])]),v._v(" "),a("p",[v._v("环境问题")]),v._v(" "),a("ol",[a("li",[v._v("jps（jdk提供的工具）查看正在运行的java进程/或者使用top命令找到cpu占用高的进程")]),v._v(" "),a("li",[v._v("使用jstack 进程id：查看线程堆栈信息（可以看到报错的代码位置）")]),v._v(" "),a("li",[v._v("使用jconsole（jdk可视化工具 排查）")]),v._v(" "),a("li",[v._v("jmap导出dump文件，通过eclipse memory analyzer 分析")])]),v._v(" "),a("p",[a("strong",[v._v("ThreadLocal的应用和问题")])]),v._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/outsanding/article/details/104418018",target:"_blank",rel:"noopener noreferrer"}},[v._v("理解ThreadLocal"),a("OutboundLink")],1)]),v._v(" "),a("p",[v._v("什么是ThreadLocal")]),v._v(" "),a("ol",[a("li",[v._v("相比起synchronized实现线程安全，是空间换时间")]),v._v(" "),a("li",[v._v("线程独立的私有空间")]),v._v(" "),a("li",[v._v("ThreadLocal实例中内部类ThreadLocalMap中存储了当前线程为key, initialValue中的值为对应的值")])]),v._v(" "),a("p",[v._v("内存泄露过程及解决方案")]),v._v(" "),a("p",[a("em",[v._v("内存泄漏MemoryLeak（占用内存不释放） 会导致内存溢出 OutOfMemory（没有足够的内存分配）")])]),v._v(" "),a("p",[v._v("在不使用ThreadLocalMap到线程结束的过程中，ThreadLocalMap有一个弱引用的静态内部类Entry< ThreadLocal t, T v >（weekRefrence），其中value是强引用，所以不会被gc掉，有内存泄漏风险。\n可以通过调用ThreadLocal.remove()方法显式设置为null")]),v._v(" "),a("p",[v._v("在线程池中使用ThreadLocal的风险")]),v._v(" "),a("ol",[a("li",[v._v("ThreadLocal本质是为每个线程提供一个副本，线程池会存在线程重复利用，所以可能存在上一次处理的结果对下一次处理结果造成影响;解决方案：在run方法里调用remove()")]),v._v(" "),a("li",[v._v("线程不销毁，线程中的v一直未销毁，在tab数组中会一直堆积entry实例；解决方法也是调用ThreadLocal实例的remove()方法")])]),v._v(" "),a("h3",{attrs:{id:"todo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#todo"}},[v._v("#")]),v._v(" TODO")]),v._v(" "),a("ol",[a("li",[v._v("当前使用的数据库版本，数据库配置")]),v._v(" "),a("li",[v._v("如何处理慢sql？集sql优化")]),v._v(" "),a("li",[v._v("springapplication的流程")]),v._v(" "),a("li",[v._v("springclound的组件")]),v._v(" "),a("li",[v._v("spring bean的生命周期")]),v._v(" "),a("li",[v._v("加索引是行锁还是表锁")]),v._v(" "),a("li",[v._v("spring默认的事务传播级别，嵌套事务如何解决")]),v._v(" "),a("li",[v._v("数据库被锁如何操作")])])])}),[],!1,null,null,null);_.default=l.exports}}]);