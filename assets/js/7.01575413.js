(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{454:function(t,_,v){t.exports=v.p+"assets/img/1664295176495.22835127.png"},455:function(t,_,v){t.exports=v.p+"assets/img/1664371738364.b31a70be.png"},456:function(t,_,v){t.exports=v.p+"assets/img/Snipaste_2022-11-25_10-31-55.5a84fe60.png"},457:function(t,_,v){t.exports=v.p+"assets/img/Snipaste_2022-09-28_21-54-54.7dd22578.png"},458:function(t,_,v){t.exports=v.p+"assets/img/Snipaste_2022-09-28_22-12-56.831483b7.png"},459:function(t,_,v){t.exports=v.p+"assets/img/Snipaste_2022-09-28_22-09-56.d8ea8759.png"},498:function(t,_,v){"use strict";v.r(_);var e=v(33),r=Object(e.a)({},(function(){var t=this,_=t.$createElement,e=t._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"网络io模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#网络io模型"}},[t._v("#")]),t._v(" 网络IO模型")]),t._v(" "),e("blockquote",[e("p",[t._v("网络io模型是用来接受和发送数据的通道模型。JAVA共支持NIO\\BIO\\AIO三种网络IO模型")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://mp.weixin.qq.com/s/7DrH3vdl0xVJp97Q-fjTAA",target:"_blank",rel:"noopener noreferrer"}},[t._v("Netty学习前基本知识 — BIO 、NIO 、AIO 总结 (qq.com)"),e("OutboundLink")],1)])]),t._v(" "),e("h2",{attrs:{id:"基础概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基础概念"}},[t._v("#")]),t._v(" 基础概念")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://www.zhihu.com/question/19732473",target:"_blank",rel:"noopener noreferrer"}},[t._v("怎样理解阻塞非阻塞与同步异步的区别？"),e("OutboundLink")],1)]),t._v(" "),e("ul",[e("li",[t._v("同步：发起调用后，被调用者未处理完请求前，不返回调用。")]),t._v(" "),e("li",[t._v("异步：发起调用后，立刻得到表示已收到调用的返回（非调用结果）。被调用者继续处理，通常依赖回调机制来通知调用者其执行结果。")]),t._v(" "),e("li",[t._v("阻塞：发起请求后，当前线程等待调用结果返回。")]),t._v(" "),e("li",[t._v("非阻塞：发起请求后，调用方不用一致等待结果返回，先去执行别的事情。")])]),t._v(" "),e("blockquote",[e("p",[t._v("两者其实很类似，只是描述角度不同，前者更描述的是交互行为，后面描述的是自己的状态")])]),t._v(" "),e("p",[e("em",[t._v("所有系统IO都分为2部分，等到就绪（不适用cpu） 和 操作")])]),t._v(" "),e("h2",{attrs:{id:"bio-blocking-i-o"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bio-blocking-i-o"}},[t._v("#")]),t._v(" BIO （blocking I/O）")]),t._v(" "),e("p",[t._v("同步阻塞I/O，典型的  "),e("strong",[t._v("一请求一应答通信模型")]),t._v(" 。")]),t._v(" "),e("p",[e("img",{attrs:{src:v(454),alt:"1664295176495"}})]),t._v(" "),e("ol",[e("li",[t._v("独立的 "),e("strong",[t._v("Acceptor")]),t._v(" 线程负责监听客户端的连接，我们一般通过在 "),e("code",[t._v("while(true)")]),t._v(" 循环中服务端会调用 "),e("code",[t._v("accept()")]),t._v(" 方法等待客户端连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待当前连接的客户端的操作执行完成，不过可以通过多线程来支持多个客户端的连接，如上图所示。")]),t._v(" "),e("li",[t._v("要让BIO通信模型同时处理多个客户端请求就要多线程。（原因是 "),e("code",[t._v("socket.accept()")]),t._v("、 "),e("code",[t._v("socket.read()")]),t._v("、 "),e("code",[t._v("socket.write()")]),t._v(" 涉及的三个主要函数都是同步阻塞的）")])]),t._v(" "),e("blockquote",[e("p",[t._v("使用线程池可以在有效控制内提高cpu利用率，实现伪异步I/O模型")])]),t._v(" "),e("h3",{attrs:{id:"线程是宝贵的资源"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#线程是宝贵的资源"}},[t._v("#")]),t._v(" 线程是宝贵的资源")]),t._v(" "),e("ul",[e("li",[t._v("线程的创建和销毁成本很高，在linux中是重量级系统函数")]),t._v(" "),e("li",[t._v("线程本身占用较大内存，java线程至少分配512k~1M")]),t._v(" "),e("li",[t._v("线程切换成本高，频繁可能会使线程切换时间比执行时间长")])]),t._v(" "),e("h3",{attrs:{id:"伪异步i-o"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#伪异步i-o"}},[t._v("#")]),t._v(" 伪异步I/O")]),t._v(" "),e("p",[t._v("采用线程池+任务队列实现")]),t._v(" "),e("p",[t._v("缺点：")]),t._v(" "),e("ul",[e("li",[t._v("read操作时阻塞操作，如果连接不做数据读写会则导致线程阻塞，浪费资源")]),t._v(" "),e("li",[t._v("线程池的线程太多，会对服务器造成压力")])]),t._v(" "),e("h2",{attrs:{id:"nio-non-blocking-io"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nio-non-blocking-io"}},[t._v("#")]),t._v(" NIO(Non Blocking IO)")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://tech.meituan.com/2016/11/04/nio.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java NIO浅析-美团技术团队"),e("OutboundLink")],1)]),t._v(" "),e("blockquote",[e("p",[t._v("同步非阻塞，服务器实现模式为一个线程可以处理多个请求（连接），客户端发送的连接请求都会注册到 "),e("strong",[t._v("多路复用器 selector")]),t._v(" 上，多路复用器轮询到连接有 IO 请求就进行处理。")]),t._v(" "),e("p",[t._v("它支持面向缓冲的，基于"),e("strong",[t._v("通道")]),t._v("的I/O操作方法。NIO提供了与传统BIO模型中的 "),e("code",[t._v("Socket")]),t._v(" 和 "),e("code",[t._v("ServerSocket")]),t._v(" 相对应的 "),e("code",[t._v("SocketChannel")]),t._v(" 和 "),e("code",[t._v("ServerSocketChannel")]),t._v(" 两种不同的套接字通道实现，两种通道都支持阻塞和非阻塞两种模式。")])]),t._v(" "),e("h3",{attrs:{id:"nio核心组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nio核心组件"}},[t._v("#")]),t._v(" NIO核心组件")]),t._v(" "),e("ul",[e("li",[t._v("channel（通道），双向，可读也可以写，而流是单向的")]),t._v(" "),e("li",[t._v("buffer（缓冲区），在NIO中所有数据都在缓冲区中处理")]),t._v(" "),e("li",[t._v("selector（选择器）")])]),t._v(" "),e("p",[e("img",{attrs:{src:v(455),alt:"1664371738364"}})]),t._v(" "),e("p",[t._v("BIO：后端线程需要阻塞等待客户端写数据,如果客户端不写数据就阻塞")]),t._v(" "),e("p",[t._v("NIO：selector负责轮询所有已注册的客户端，发现有事件发生才转给后端线程处理，后端线程不需要阻塞等待，且channel的读写非阻塞，通过这种方式，甚至单线程都能做到高效的复用，最典型的例子就是Redis了。\n"),e("img",{attrs:{src:v(456),alt:"1664371738364"}})]),t._v(" "),e("h3",{attrs:{id:"选择器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#选择器"}},[t._v("#")]),t._v(" 选择器")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://blog.csdn.net/qq_25928447/article/details/124594600?spm=1001.2014.3001.5501",target:"_blank",rel:"noopener noreferrer"}},[t._v("NIO浅谈代码"),e("OutboundLink")],1),t._v("\n选择器作用就是 某一状态已就绪时触发线程处理。selector的实现方案：")]),t._v(" "),e("ul",[e("li",[t._v("select，存在有连接准备就绪时，能够知道但是不能知道具体是哪一个来连接，需要线性遍历所有连接，时间复杂度为O(n),有最大链接数限制")]),t._v(" "),e("li",[t._v("poll，底层采用链表，理论没有最大连接数限制")]),t._v(" "),e("li",[t._v("epoll，事件通知方式，内核实现中epoll是根据每个fd（文件描述符）上面的callback函数实现，只要就绪就会回调callback函数，精准通知。事件复杂度为O（1），目前只有linux支持")])]),t._v(" "),e("h2",{attrs:{id:"aio-asynchronous-i-o"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aio-asynchronous-i-o"}},[t._v("#")]),t._v(" AIO（Asynchronous I/O）")]),t._v(" "),e("blockquote",[e("p",[t._v("是异步非阻塞的IO模型，异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。")])]),t._v(" "),e("p",[t._v("适合于连接数目多且连接比较长（重操作）的架构")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th"),t._v(" "),e("th",[e("strong",[t._v("BIO")])]),t._v(" "),e("th",[e("strong",[t._v("NIO")])]),t._v(" "),e("th",[t._v("AIO")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[e("strong",[t._v("IO模型")])]),t._v(" "),e("td",[t._v("同步阻塞")]),t._v(" "),e("td",[t._v("同步非阻塞（多路复用）")]),t._v(" "),e("td",[t._v("异步非阻塞")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("编程难度")])]),t._v(" "),e("td",[t._v("简单")]),t._v(" "),e("td",[t._v("复杂")]),t._v(" "),e("td",[t._v("复杂")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("可靠性")])]),t._v(" "),e("td",[t._v("差")]),t._v(" "),e("td",[t._v("好")]),t._v(" "),e("td",[t._v("好")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("吞吐量")])]),t._v(" "),e("td",[t._v("低")]),t._v(" "),e("td",[t._v("高")]),t._v(" "),e("td",[t._v("高")])])])]),t._v(" "),e("h4",{attrs:{id:"答疑"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#答疑"}},[t._v("#")]),t._v(" 答疑")]),t._v(" "),e("blockquote",[e("ol",[e("li",[e("p",[t._v("IO是什么\n数据通过媒介读取和写入都是IO，网络IO流程：网卡->内核空间->用户空间->应用程序")])]),t._v(" "),e("li",[e("p",[t._v("NIO是不是就是I/O多路复用?\n"),e("img",{attrs:{src:"https://blog.csdn.net/weixin_43753797/article/details/115274744",alt:""}}),t._v("\n以下是多路复用的流程，网卡还没准备好写入到内核空间时候，直接返回程序未就绪，该线程继续别的事情，直到数据准备好，通知对应的请求进行IO（IO过程是阻塞的），其他请求等待是同步的，但是程序处理请求时非阻塞的.\n"),e("img",{attrs:{src:v(457),alt:"NIO"}}),t._v(" "),e("img",{attrs:{src:v(458),alt:"NIO"}}),t._v(" "),e("img",{attrs:{src:v(459),alt:"多路复用"}})]),t._v(" "),e("p",[t._v("NIO相当于多路复用的必要条件。")])])])])])}),[],!1,null,null,null);_.default=r.exports}}]);