(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{495:function(_,t,v){"use strict";v.r(t);var e=v(33),s=Object(e.a)({},(function(){var _=this,t=_.$createElement,v=_._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"mysql答疑"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql答疑"}},[_._v("#")]),_._v(" Mysql答疑")]),_._v(" "),v("h2",{attrs:{id:"mysql索引实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql索引实现"}},[_._v("#")]),_._v(" mysql索引实现")]),_._v(" "),v("ol",[v("li",[_._v("mysql索引实现：\n"),v("ol",[v("li",[_._v("hash：哈希表，通过key的哈希值找到value，"),v("strong",[_._v("很快")]),_._v("，"),v("strong",[_._v("但不支持范围查询和排序查询")]),_._v("；时间复杂度O(1),排序会退化为O(N),树形结构永远是O(log(n))\n"),v("ul",[v("li",[_._v("不能利用联合索引中的部分索引查询（联合索引通过合起来hash生成）")]),_._v(" "),v("li",[_._v("不能避免表扫描，哈希碰撞时还是要比对")]),_._v(" "),v("li",[_._v("大量hash碰撞，性能会下降")])])]),_._v(" "),v("li",[_._v("b-tree：自平衡的多路搜索树，b代表balance，比起二叉树，树高度低，IO次数小")]),_._v(" "),v("li",[_._v("bitmap，大多数不支持，mysql不支持")])])])]),_._v(" "),v("h2",{attrs:{id:"b-tree和b-tree"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#b-tree和b-tree"}},[_._v("#")]),_._v(" b-tree和b+tree")]),_._v(" "),v("blockquote",[v("p",[v("a",{attrs:{href:"https://www.jianshu.com/p/ace3cd6526c4",target:"_blank",rel:"noopener noreferrer"}},[_._v("B+树和B树的区别 - 简书 (jianshu.com)"),v("OutboundLink")],1)])]),_._v(" "),v("ol",[v("li",[_._v("b树\n"),v("ol",[v("li",[_._v("所有结点和叶节点都存储索引和data数据")]),_._v(" "),v("li",[_._v("搜索可能在一个节点结束，最低复杂度为O(1)")]),_._v(" "),v("li",[_._v("任何一个关键字出现且只出现在一个结点")])])]),_._v(" "),v("li",[_._v("b+树\n"),v("ol",[v("li",[_._v("所有关键字在叶子结点内出现，结点只存储关键字，叶节点存储索引和data数据，复杂度为固定log(n)")]),_._v(" "),v("li",[_._v("为所有叶子节点添加一个链指针，大大增加区间访问性，利用了空间局部性原理")]),_._v(" "),v("li",[_._v("内结点没有data，所以单次IO信息量比b-tree大")])])])]),_._v(" "),v("h2",{attrs:{id:"mysql的引擎"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql的引擎"}},[_._v("#")]),_._v(" mysql的引擎")]),_._v(" "),v("ol",[v("li",[_._v("myISAM：\n"),v("ol",[v("li",[_._v("b+tree叶节点存放数据地址，先根据索引找到对应的地址，再根据"),v("strong",[_._v("地址")]),_._v("读取数据，称为"),v("strong",[_._v("非聚集索引")])]),_._v(" "),v("li",[_._v("保存了count的值，所以count频繁的场景很快，适合查询频繁")])])]),_._v(" "),v("li",[_._v("innoDB（必须有主键，密集索引）:\n"),v("ol",[v("li",[_._v("主键索引是聚集索引，主键和行记录放在同一个叶节点，找到主键即找到行记录；")]),_._v(" "),v("li",[_._v("非主键索引都是非聚集索引，innoDB的非聚集索引的索引文件和数据文件分开存储，叶节点保存的是"),v("strong",[_._v("主键")]),_._v("，所以还需要根据主键去"),v("strong",[_._v("索引文件找详细行记录")]),_._v("。"),v("strong",[_._v("主键字段不宜过长")])])])])]),_._v(" "),v("blockquote",[v("p",[_._v("两者的区别：InnoDB是事务型引擎，支持事务，基于聚簇索引建立（主键索引），是行锁,也支持表级锁,当不走索引的时候整张表用的是表级锁，走索引的时候用到的是行级锁；\n而myISAM不支持事务（后续已经支持）和行级锁，是对整张表加锁，所有读锁释放了，写锁才可以进行，写锁是排他锁，读锁是共享锁，加了共享锁，无法再加排他锁,海量写入数据时会阻塞查询。")])]),_._v(" "),v("h2",{attrs:{id:"回表查询"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#回表查询"}},[_._v("#")]),_._v(" 回表查询")]),_._v(" "),v("p",[_._v("在innoDB引擎中，非主键索引查找数据需要先找到主键，再根据主键查找具体行数据，就叫回表查询")]),_._v(" "),v("h2",{attrs:{id:"数据库事务-acid"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据库事务-acid"}},[_._v("#")]),_._v(" 数据库事务（ACID）")]),_._v(" "),v("ul",[v("li",[_._v("ATOMIC")]),_._v(" "),v("li",[_._v("CONSISTENCY")]),_._v(" "),v("li",[_._v("ISOLATION")]),_._v(" "),v("li",[_._v("DURATION")])]),_._v(" "),v("h3",{attrs:{id:"问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[_._v("#")]),_._v(" 问题")]),_._v(" "),v("ol",[v("li",[_._v("脏读:能读到未提交的结果 解决方法：读已提交 （Oracle默认隔离级别）")]),_._v(" "),v("li",[_._v("不可重复读：在自己事务提交前，多次读取结果不一致（别的事务操作提交了） 解决方法：可重复读（innordb默认隔离级别）")]),_._v(" "),v("li",[_._v("幻读： 解决方法：串行化")])]),_._v(" "),v("h3",{attrs:{id:"当前读-快照读"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#当前读-快照读"}},[_._v("#")]),_._v(" 当前读/快照读")]),_._v(" "),v("p",[_._v("当前读：最新版数据\n快照读: 不加锁的读，串行化下除外，（RR）快照读的时机决定读数据的版本")]),_._v(" "),v("h2",{attrs:{id:"应用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#应用"}},[_._v("#")]),_._v(" 应用")]),_._v(" "),v("div",{staticClass:"language-sql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-sql"}},[v("code",[v("span",{pre:!0,attrs:{class:"token comment"}},[_._v("-- 查看是否打开慢sql查询")]),_._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("show")]),_._v(" variables "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("like")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[_._v("'%query%'")]),_._v("\n"),v("span",{pre:!0,attrs:{class:"token comment"}},[_._v("-- 查询本次慢sql条数")]),_._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("show")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("status")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("like")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[_._v("'%slow_queries%'")]),_._v("\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br"),v("span",{staticClass:"line-number"},[_._v("2")]),v("br"),v("span",{staticClass:"line-number"},[_._v("3")]),v("br"),v("span",{staticClass:"line-number"},[_._v("4")]),v("br")])]),v("h3",{attrs:{id:"explain-执行计划关键字段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#explain-执行计划关键字段"}},[_._v("#")]),_._v(" explain 执行计划关键字段")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("列名")]),_._v(" "),v("th",[_._v("说明")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("id")]),_._v(" "),v("td",[_._v("执行编号，id值越大，执行优先级越高，相同id值，从上往下执行")])]),_._v(" "),v("tr",[v("td",[_._v("select_type")]),_._v(" "),v("td",[_._v("查询的类型，主要区分是普通查询、联合查询、子查询等")])]),_._v(" "),v("tr",[v("td",[_._v("type")]),_._v(" "),v("td",[_._v("数据访问/读取操作类型，system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL ，一般来说，得保证查询至少达到 range 级别，最好能达到 ref")])]),_._v(" "),v("tr",[v("td",[_._v("possible_keys")]),_._v(" "),v("td",[_._v("可能是用的索引")])]),_._v(" "),v("tr",[v("td",[_._v("key")]),_._v(" "),v("td",[_._v("实际使用的索引")])]),_._v(" "),v("tr",[v("td",[_._v("key_len")]),_._v(" "),v("td",[_._v("使用的索引的长度，长度越短越好 。")])]),_._v(" "),v("tr",[v("td",[_._v("ref")]),_._v(" "),v("td",[_._v("ref 列展示的就是与索引列作等值匹配的对象是啥。如果不是等值查询，则显示为 NULL")])]),_._v(" "),v("tr",[v("td",[_._v("rows")]),_._v(" "),v("td",[_._v("执行计划的 rows 列就代表预计扫描的索引记录行数。")])]),_._v(" "),v("tr",[v("td",[_._v("filtered")]),_._v(" "),v("td",[_._v("1. 对于单表，代表满足where条件的行数占查询行数百分比，意义不大。"),v("br"),_._v("2. 对于关联表，代表驱动表的一个扇出效率 rows*filter/100 = 扇出次数，被驱动表需要执行的次数")])]),_._v(" "),v("tr",[v("td",[_._v("extra")]),_._v(" "),v("td",[_._v("Extra 是 EXPLAIN 输出中另外一个很重要的列，该列显示 MySQL 在查询过程中的一些详细信息")])])])]),_._v(" "),v("ol",[v("li",[v("p",[_._v("访问类型type")]),_._v(" "),v("ul",[v("li",[_._v("const:根据主键索引 or 唯一 二级索引 与常数进行等值匹配")]),_._v(" "),v("li",[_._v("ref:使用普通二级索引和常量进行等值匹配")]),_._v(" "),v("li",[_._v("fulltext：全文索引")]),_._v(" "),v("li",[_._v("range:使用索引获取某些范围区间的记录")]),_._v(" "),v("li",[_._v("index:需要扫描全部的索引记录")]),_._v(" "),v("li",[_._v("all:全表扫描")])])]),_._v(" "),v("li",[v("p",[_._v("extra")]),_._v(" "),v("ul",[v("li",[_._v("using filesort：外部排序，无法利用索引完成排序，需要额外在内存或磁盘上排序")]),_._v(" "),v("li",[_._v("using temporary: 使用了临时表保存中间结果，常见group by / order by，一般看到说明需要进行查询优化")])])])]),_._v(" "),v("h3",{attrs:{id:"sql优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#sql优化"}},[_._v("#")]),_._v(" SQL优化")]),_._v(" "),v("blockquote",[v("p",[_._v("原则")]),_._v(" "),v("ul",[v("li",[_._v("最大化利用索引")]),_._v(" "),v("li",[_._v("尽可能避免全表扫描")]),_._v(" "),v("li",[_._v("减少无效数据查询")])])]),_._v(" "),v("ol",[v("li",[_._v("避免不走索引\n"),v("ul",[v("li",[_._v("避免全模糊查询，尽量在字段后面使用模糊查询（数据量过大建议使用其他解决方案，es等）")]),_._v(" "),v("li",[_._v("避免使用or查询条件")]),_._v(" "),v("li",[_._v("避免在where条件等号的左侧使用表达式、函数操作")]),_._v(" "),v("li",[_._v("不符合最左匹配原则，复合索引没有生效")]),_._v(" "),v("li",[_._v("隐式类型转换不走索引，varchar=123")]),_._v(" "),v("li",[_._v("order by没有和where条件一致，排序不走索引")])])]),_._v(" "),v("li",[_._v("查询优化\n"),v("ul",[v("li",[_._v("避免使用select *，按需获取列数")]),_._v(" "),v("li",[_._v("多表关联时，小表驱动大表")])])])])])}),[],!1,null,null,null);t.default=s.exports}}]);