(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{486:function(s,t,a){"use strict";a.r(t);var n=a(33),e=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"java的锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java的锁"}},[s._v("#")]),s._v(" JAVA的锁")]),s._v(" "),a("p",[a("a",{attrs:{href:"https://tech.meituan.com/2018/11/15/java-lock.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("不可不说的Java“锁”事 - 美团技术团队 (meituan.com)"),a("OutboundLink")],1)]),s._v(" "),a("h2",{attrs:{id:"一、java中的锁是通过功能特性来定义的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、java中的锁是通过功能特性来定义的"}},[s._v("#")]),s._v(" 一、java中的锁是通过功能特性来定义的")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e66cfe1d-a9c8-4ab2-8ae9-cc5aa0d2291b/Untitled.png",alt:"Untitled"}})]),s._v(" "),a("h2",{attrs:{id:"二、乐观锁-vs-悲观锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、乐观锁-vs-悲观锁"}},[s._v("#")]),s._v(" 二、乐观锁 vs 悲观锁")]),s._v(" "),a("p",[s._v("乐观锁：乐观认为当前资源没有被加锁，做更改哪一刻才去看有没锁 （通过版本号更新）")]),s._v(" "),a("p",[s._v("悲观锁：悲观认为有别的线程在竞争锁，先加锁，确保不会被别的线程修改 （显式加锁）")]),s._v(" "),a("div",{staticClass:"language-html line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[s._v("---------悲观锁------------\nsynchronized修饰 reentrantLock  \n---------乐观锁------------\nprivate AtomicInteger atomicInteger = new AtomicInteger();  // 需要保证多个线程使用的是同一个AtomicInteger\natomicInteger.incrementAndGet(); //执行自增1\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("乐观锁主要实现：CAS (Compare And Swap) 比较与交换 ，无锁算法，底层原子操作，会循环重试，高效")]),s._v(" "),a("p",[s._v("CAS问题：")]),s._v(" "),a("ol",[a("li",[a("strong",[s._v("ABA问题")]),s._v(" 通过版本号解决，1A-2B-3C")]),s._v(" "),a("li",[a("strong",[s._v("循环开销大")]),s._v("，如果长时间不成功，会一直自旋")]),s._v(" "),a("li",[s._v("只能保证"),a("strong",[s._v("一个共享变量的原子操作")])])]),s._v(" "),a("h2",{attrs:{id:"三、自旋锁-vs-适应性自旋锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、自旋锁-vs-适应性自旋锁"}},[s._v("#")]),s._v(" 三、自旋锁 vs 适应性自旋锁")]),s._v(" "),a("ol",[a("li",[s._v("避免频繁切换处理耗费时间大于循环等待执行的时间，因此让当前线程自旋从而避免切换线程的开销，就要自旋锁，实现原理也是CAS；")]),s._v(" "),a("li",[s._v("在JDK 6中引入适应性自旋锁，自适应意味着自旋次数不再固定，如果某个锁经常成功，那么就会允许自旋等待较长时间，如果经常失败，那么可能直接阻塞线程，避免浪费处理器资源。")])]),s._v(" "),a("p",[a("img",{attrs:{src:"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6750cb43-3c2d-49ce-b318-c6048d706295/Untitled.png",alt:"Untitled"}})]),s._v(" "),a("h2",{attrs:{id:"四、为什么synchronized能实现线程同步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、为什么synchronized能实现线程同步"}},[s._v("#")]),s._v(" 四、为什么synchronized能实现线程同步")]),s._v(" "),a("blockquote",[a("p",[s._v("背景：monitor存在每个对象的对象头中，每个对象都有一把内部锁：monitor锁，ObjectMonitor\n每个线程有一个可用的monitor record列表")])]),s._v(" "),a("p",[a("strong",[s._v("java对象头：")]),s._v(" synchronized是悲观锁，操作同步资源之前先加锁，锁就存在java对象头")]),s._v(" "),a("p",[a("strong",[s._v("mark word")]),s._v(":默认存放与"),a("strong",[s._v("对象定义无关的数据")]),s._v("：hashCode，分代年龄，锁标志位，会随着标记位变化而变化")]),s._v(" "),a("p",[a("strong",[s._v("class Point")]),s._v(":指向"),a("strong",[s._v("类元数据")]),s._v("的指针")]),s._v(" "),a("p",[s._v("**Monitor：**同步工具或同步机制，"),a("strong",[s._v("对象私有")]),s._v("的数据结构")]),s._v(" "),a("p",[s._v("synchronized是通过Monitor实现线程同步，基于进入和退出monitor对象实现同步。线程执行到monitorenter指令时将会尝试获取对象对应的monitor所有权（即尝试获取对象的锁）")]),s._v(" "),a("p",[a("strong",[s._v("jdk如何对锁进行优化")])]),s._v(" "),a("ol",[a("li",[s._v("锁消除：jit编译时，对运行上下文进行扫描，去除不可能存在竞争的锁。（局部方法内的synchronized）")]),s._v(" "),a("li",[s._v("锁粗化：通过扩大加锁的访问，避免反复加锁和解锁")])]),s._v(" "),a("h2",{attrs:{id:"五、无锁-vs-偏向锁-vs-轻量级锁-vs-重量级锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、无锁-vs-偏向锁-vs-轻量级锁-vs-重量级锁"}},[s._v("#")]),s._v(" 五、无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁")]),s._v(" "),a("blockquote",[a("p",[s._v("锁的内存定义：当线程释放时，java内存模型会把线程对应的本地内存中共享变量刷入主内存中，而线程获取锁时，java内存模型会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。")])]),s._v(" "),a("p",[s._v("这4种锁是指锁的状态，专门针对synchronized")]),s._v(" "),a("ol",[a("li",[s._v("无锁：\n"),a("ol",[a("li",[s._v("不加锁，所有线程都可以访问，但只有一个能修改成功，CAS原理及应用也是无锁的实现")])])]),s._v(" "),a("li",[s._v("偏向锁：\n"),a("ol",[a("li",[s._v("一段同步代码块被一个线程访问，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID。锁标志位为01")]),s._v(" "),a("li",[s._v("用于无多线程。遇到其他线程竞争时会释放锁。")])])]),s._v(" "),a("li",[s._v("轻量级锁：\n"),a("ol",[a("li",[s._v("但锁是偏向锁时，被另外线程所访问，偏向锁就会升级为轻量级锁，其他线程会自旋获取锁，不会阻塞（自己），从而提高性能，锁标志位为00")])])]),s._v(" "),a("li",[s._v("重量级锁：\n"),a("ol",[a("li",[s._v("自旋超过一定次数，或者线程超过2条，就会升级为重量级锁，锁标志位为10。")]),s._v(" "),a("li",[s._v("重量级锁是将除了拥有锁的线程以外的线程都阻塞。")])])])]),s._v(" "),a("p",[s._v("偏向锁升级为轻量级锁的过程：前提是处于偏向锁状态Thread-1持有，Thread-2竞争")]),s._v(" "),a("ol",[a("li",[s._v("Thread-1不存在，CAS替换为Thread-2")]),s._v(" "),a("li",[s._v("Thread-1存在，挂起Thread-1，撤销偏向锁，继续执行Thread-1，执行完后，锁升级为轻量级锁，Thread-2自旋获取锁")])]),s._v(" "),a("h2",{attrs:{id:"六、公平锁vs非公平锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六、公平锁vs非公平锁"}},[s._v("#")]),s._v(" 六、公平锁VS非公平锁")]),s._v(" "),a("ol",[a("li",[s._v("公平锁\n"),a("ol",[a("li",[s._v("多个线程按照申请顺序获得锁，线程会直接加入等待队列")]),s._v(" "),a("li",[s._v("等待队列中，除了第一个线程以外的都会阻塞，都需要CPU唤醒，CPU开销大")])])]),s._v(" "),a("li",[s._v("非公平锁\n"),a("ol",[a("li",[s._v("线程会尝试插队，CPU不需要增加唤醒工作量，吞吐量提高")]),s._v(" "),a("li",[s._v("如果插队失败，需要进入队列排队并阻塞，cpu需要增加唤醒工作，等同于公平锁")])])])]),s._v(" "),a("blockquote",[a("p",[s._v("代码层面，两者差不多，只是公平锁在获取同步状态时多了限制条件：hasQueuedPredecessors()")])]),s._v(" "),a("p",[a("img",{attrs:{src:"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c2a10e82-92ca-40e7-84cc-10fcf9e324a6/Untitled.png",alt:"Untitled"}})]),s._v(" "),a("h2",{attrs:{id:"七、可重入锁-vs-非可重入锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#七、可重入锁-vs-非可重入锁"}},[s._v("#")]),s._v(" 七、可重入锁 VS 非可重入锁")]),s._v(" "),a("p",[s._v("可重入锁，又叫递归锁，同一个线程在外层方法获取锁后，进入内层synchronized修饰的方法自动获取锁（前提是锁对象是同一个对象或者class）。所以在一定程度上"),a("strong",[s._v("避免了死锁")]),s._v("。")]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Widget")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("synchronized")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("doSomething")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("System")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("out"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("println")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"方法1执行..."')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("doOthers")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("synchronized")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("doOthers")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("System")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("out"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("println")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"方法2执行..."')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//线程调用方法doSomething后直接调用doOthers，因为内置锁synchronized是可重入的，如果不是的话，调用doOthers时锁还未释放，也获取不到锁，变成死锁。")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("p",[a("strong",[s._v("synchronized和reentrantLock都是重入锁")])]),s._v(" "),a("h2",{attrs:{id:"八、独享锁-vs-共享锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#八、独享锁-vs-共享锁"}},[s._v("#")]),s._v(" 八、独享锁 VS 共享锁")]),s._v(" "),a("p",[s._v("独享锁和共享锁同样是一种概念。")]),s._v(" "),a("ol",[a("li",[s._v("**独享锁：**排他锁，该锁一次只能被一个线程持有，"),a("strong",[s._v("获取排他锁既能读也能写")]),s._v("（synchronized和Lock都是）")]),s._v(" "),a("li",[s._v("**共享锁：**指该锁可以被多个线程持有，如果线程T对数据A加上共享锁后，其他线程只能对A再添加共享锁，不能加排他锁。"),a("strong",[s._v("共享锁只能读数据，不能修改")]),s._v("。")]),s._v(" "),a("li",[s._v("如果存在读锁，那么就会获取写锁失败，因为要保证读写一致。如果存在写锁，那么读锁要等写锁释放才能获取。")])]),s._v(" "),a("blockquote",[a("p",[s._v("公平锁和非公平锁，只要当前线程不是拥有锁的线程都不能添加锁，所以都是独享锁")])])])}),[],!1,null,null,null);t.default=e.exports}}]);