(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{422:function(t,s,a){t.exports=a.p+"assets/img/Snipaste_2022-08-30_22-32-07.043f12d1.png"},423:function(t,s,a){t.exports=a.p+"assets/img/Snipaste_2022-08-30_22-38-46.55409fd6.png"},482:function(t,s,a){"use strict";a.r(s);var e=a(33),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"浅谈redis"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浅谈redis"}},[t._v("#")]),t._v(" 浅谈Redis")]),t._v(" "),e("blockquote",[e("p",[t._v("remote dictionary server 是基于"),e("strong",[t._v("内存")]),t._v("的高性能key-value的储存系统，跨平台非关系型数据库，,"),e("strong",[t._v("快")]),t._v("，每秒可达10万次可持久化的"),e("strong",[t._v("键值对")]),t._v("存储数据库。"),e("a",{attrs:{href:"https://www.cnblogs.com/wmyskxz/p/12568926.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("redis概要"),e("OutboundLink")],1)])]),t._v(" "),e("h2",{attrs:{id:"优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),e("ol",[e("li",[e("code",[t._v("读写性能优异")]),t._v("，基于内存，单线程无锁竞争，读11/s,写8w/s")]),t._v(" "),e("li",[e("code",[t._v("数据类型丰富")]),t._v(" String set zset hash list，单个value最大限制是1GB，在基础数据结构之上还提供高级数据结构")]),t._v(" "),e("li",[e("code",[t._v("可持久化")]),t._v("（RDB和AOF）")]),t._v(" "),e("li",[e("code",[t._v("高可用")]),t._v("内置redis sentinel 实现主从故障自动，而且一些合并操作也是原子性")]),t._v(" "),e("li",[e("code",[t._v("支持主从复制")]),t._v("，可以进行读写分离")])]),t._v(" "),e("h2",{attrs:{id:"缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),e("ol",[e("li",[t._v("受物理内存限制")]),t._v(" "),e("li",[t._v("较难在线扩容和修改配置")]),t._v(" "),e("li",[t._v("引入新的组件需要维护")])]),t._v(" "),e("blockquote",[e("p",[t._v("Redis和Memcached的区别")]),t._v(" "),e("ol",[e("li",[t._v("redis支持复杂的数据结构")]),t._v(" "),e("li",[t._v("redis原生支持集群,3.x开始")]),t._v(" "),e("li",[t._v("redis只使用单核，memcached可以使用多核，100k以上的数据，后者性能要高")]),t._v(" "),e("li",[t._v("管理机制不通过，redis是现场申请内存，Memcached是预分配的内存池")]),t._v(" "),e("li",[t._v("网络IO模型不同，redis是单线程的IO多路复用模型，Memcached是多线程非阻塞IO复用")]),t._v(" "),e("li",[t._v("Memcached不支持持久化，重启数据会被清空")])])]),t._v(" "),e("blockquote",[e("p",[t._v("为什么单线程性能这么高")]),t._v(" "),e("ol",[e("li",[t._v("C语言实现，C语言执行快")]),t._v(" "),e("li",[t._v("纯内存操作，数据读到内存中，异步进行持久化")]),t._v(" "),e("li",[t._v("基于同步非阻塞的IO多路复用机制")]),t._v(" "),e("li",[t._v("单线程，避免频繁的线程切换")])])]),t._v(" "),e("blockquote",[e("p",[t._v("为什么要用redis？\n日常应用，读远多于写，数据库查询数据需要从磁盘读取，相对较慢，redis直接读内存 "),e("code",[t._v("（高性能）")]),t._v("，速度快，同时减少数据库压力 "),e("code",[t._v("(高并发)")])])]),t._v(" "),e("h2",{attrs:{id:"使用redis会出现的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用redis会出现的问题"}},[t._v("#")]),t._v(" 使用redis会出现的问题")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("问题")]),t._v(" "),e("th",[t._v("原因")]),t._v(" "),e("th",[t._v("solve")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("雪崩")]),t._v(" "),e("td",[e("strong",[t._v("同一时间")]),t._v("大量缓存"),e("strong",[t._v("失效")]),t._v("，导致短期内全部请求数据库，造成压力激增")]),t._v(" "),e("td",[t._v("1. 缓存失效时间"),e("strong",[t._v("添加随机值")]),t._v(" "),e("br"),t._v("2. 调高hz值，提高redis主动淘汰的频率")])]),t._v(" "),e("tr",[e("td",[t._v("缓存穿透")]),t._v(" "),e("td",[t._v("查询一个不存在缓存中的数据，数量过多同样会拖垮数据库")]),t._v(" "),e("td",[t._v("1. 使用"),e("strong",[t._v("布隆过滤器")]),t._v("提前拦截 "),e("br"),t._v("2. 把不存在的数据也放到缓存中，设置较短的失效时间")])]),t._v(" "),e("tr",[e("td",[t._v("一致性问题")]),t._v(" "),e("td",[t._v("更新redis和数据库无法满足原子性")]),t._v(" "),e("td",[t._v("消息队列+重试")])])])]),t._v(" "),e("h2",{attrs:{id:"数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[t._v("#")]),t._v(" 数据结构")]),t._v(" "),e("blockquote",[e("p",[t._v("内部会使用"),e("strong",[t._v("redisObject")]),t._v("对象来表示所有的key和value，其次针对不同的value采用不同的底层数据结构来实现")])]),t._v(" "),e("h3",{attrs:{id:"基础数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基础数据结构"}},[t._v("#")]),t._v(" 基础数据结构")]),t._v(" "),e("ol",[e("li",[t._v("string（二进制安全，sds动态字符串），可用于处理每日访问数量"),e("div",{staticClass:"language-redis line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("   incr userId221114\n   get userId221114\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br")])])]),t._v(" "),e("li",[t._v("List,按照string元素插入顺序排序"),e("div",{staticClass:"language-redis line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("   lpush mylist aaa\n   lrange  mylist 0-10\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br")])])]),t._v(" "),e("li",[t._v("set,通过hash表实现，不允许重复，集合的操作")]),t._v(" "),e("li",[t._v("sortedSet")]),t._v(" "),e("li",[t._v("hash,String元素组成的字典，适合用于存储对象")])]),t._v(" "),e("h3",{attrs:{id:"高级数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#高级数据结构"}},[t._v("#")]),t._v(" 高级数据结构")]),t._v(" "),e("ol",[e("li",[t._v("HyperLogLog 用于基数统计的算法，优点是节省内存空间，因为只会根据输入元素来计算基数，不存储元素本身。")]),t._v(" "),e("li",[t._v("GEO 主要用来存储地理位置信息及操作")]),t._v(" "),e("li",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/67920410",target:"_blank",rel:"noopener noreferrer"}},[t._v("bitmap"),e("OutboundLink")],1),t._v(":BloomFilter 布隆过滤器，利用了bitMap，内存占用小，插入查询快，能够判断一定不存在，但无法判断一定存在，而且无法删除数据。可应用于解决缓存击穿和黑名单校验。\n"),e("ul",[e("li",[t._v("布隆过滤器：当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组（bitmap）中的K个点，把它们置为1。插入查询时间复杂度为O(K)")])])])]),t._v(" "),e("h3",{attrs:{id:"持久化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#持久化"}},[t._v("#")]),t._v(" 持久化")]),t._v(" "),e("p",[t._v("持久化就是将数据保存到磁盘中的过程")]),t._v(" "),e("blockquote",[e("p",[t._v("持久化发生了什么")]),t._v(" "),e("ol",[e("li",[t._v("客户端向数据库发送写命令（客户端内存）")]),t._v(" "),e("li",[t._v("数据库接收到写请求（服务器内存）")]),t._v(" "),e("li",[t._v("数据库调用系统api写入磁盘（系统内核缓冲区）")]),t._v(" "),e("li",[t._v("操作系统将写缓冲区传输到磁盘控制器（磁盘缓冲区）")]),t._v(" "),e("li",[t._v("磁盘控制器写入到实际的物理媒介中（物理媒介）")])])]),t._v(" "),e("p",[t._v("两个备份命令：SAVR（阻塞知道rdb文件被创建完） 和 BGSAVE（fork一个子进程，不阻塞）")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("自动触发rdb持久化方式")]),t._v(" "),e("ul",[e("li",[t._v("通过配置里面SAVE 时间 次数（用的bgsave）")]),t._v(" "),e("li",[t._v("主从复制，主往从复制")]),t._v(" "),e("li",[t._v("执行shutdown且没有开启aof持久化")])])]),t._v(" "),e("li",[e("p",[t._v("Redis快照-rdb，全量，实际操作时fork一个子进程处理，使用的是rdbSave（缺点，消耗性能，有丢失最新数据可能）")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("包含两个核心函数rdbSave和rdbLoad")]),t._v(" "),e("ul",[e("li",[t._v("SAVE直接调用rdbSave，并在完成前阻塞调用者，期间，AOF 写入可以在后台线程进行， "),e("a",{attrs:{href:"http://redis.readthedocs.org/en/latest/server/bgrewriteaof.html#bgrewriteaof",title:"(in Redis 命令参考 v2.8)",target:"_blank",rel:"noopener noreferrer"}},[t._v("BGREWRITEAOF"),e("OutboundLink")],1),t._v(" 可以在子进程进行")]),t._v(" "),e("li",[t._v("BGSAVE用子进程调用rdbSave，主进程仍可以继续处理命令请求\n"),e("ul",[e("li",[t._v("原理是 fork 和 cow ：fork子进程，copy on write")])])]),t._v(" "),e("li",[t._v("为了避免性能问题， "),e("a",{attrs:{href:"http://redis.readthedocs.org/en/latest/server/bgsave.html#bgsave",title:"(in Redis 命令参考 v2.8)",target:"_blank",rel:"noopener noreferrer"}},[t._v("BGSAVE"),e("OutboundLink")],1),t._v(" 和 "),e("a",{attrs:{href:"http://redis.readthedocs.org/en/latest/server/bgrewriteaof.html#bgrewriteaof",title:"(in Redis 命令参考 v2.8)",target:"_blank",rel:"noopener noreferrer"}},[t._v("BGREWRITEAOF"),e("OutboundLink")],1),t._v(" 不能同时执")]),t._v(" "),e("li",[t._v("为了避免产生竞争条件， "),e("a",{attrs:{href:"http://redis.readthedocs.org/en/latest/server/bgsave.html#bgsave",title:"(in Redis 命令参考 v2.8)",target:"_blank",rel:"noopener noreferrer"}},[t._v("BGSAVE"),e("OutboundLink")],1),t._v(" 执行时， "),e("a",{attrs:{href:"http://redis.readthedocs.org/en/latest/server/save.html#save",title:"(in Redis 命令参考 v2.8)",target:"_blank",rel:"noopener noreferrer"}},[t._v("SAVE"),e("OutboundLink")],1),t._v(" 命令不能执行。")]),t._v(" "),e("li",[t._v("调用 rdbLoad  函数载入 RDB 文件时，不能进行任何和数据库相关的操作，不过订阅与发布方面的命令可以正常执行，因为它们和数据库不相关联。")])])])])]),t._v(" "),e("li",[e("p",[t._v("AOF（Append only file）仅追加文件，增量（只记录写删，查询不记录），数据太大会启用 "),e("strong",[t._v("rewrite")]),t._v(" 机制")]),t._v(" "),e("ul",[e("li",[t._v("也是fork一个子进程处理")]),t._v(" "),e("li",[t._v("子进程会把新的aof写到一个临时文件，不依赖原来的aof文件")]),t._v(" "),e("li",[t._v("主进程持续将新的标动写入到内存和原来AOF文件中")]),t._v(" "),e("li",[t._v("主进程获取子进程重写AOF完成信息，往新AOF同步增量变动")]),t._v(" "),e("li",[t._v("使用新的aof文件替换原来的")])])])]),t._v(" "),e("p",[t._v("bgsave原理")]),t._v(" "),e("ul",[e("li",[t._v("先检查是否存在AOF/RDB子进程正在执行，存在会被拒绝执行")]),t._v(" "),e("li",[t._v("调用rdbSaveBackground方法执行fork系统调用")]),t._v(" "),e("li",[t._v("fork用于创建进程，linux实现了cow，内核为子进程创建虚拟空间，子父共享物理空间，只有父进程发生更改时才会给子进程分配独立的物理空间")])]),t._v(" "),e("blockquote",[e("p",[t._v("区别\n快照是隔一段时间，所以数据不全，但恢复很快；而AOF是间隔很短，所以数据全，但是文件很多，恢复比较慢，恢复的过程相当于重新执行一遍命令（也不完全是，因为命令会优化，redis4.0支持混合持久化，AOF每次建立在一个快照基础上，所以不是全量。")])]),t._v(" "),e("h3",{attrs:{id:"过期策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#过期策略"}},[t._v("#")]),t._v(" 过期策略")]),t._v(" "),e("ol",[e("li",[t._v("惰性删除")]),t._v(" "),e("li",[t._v("定时删除")]),t._v(" "),e("li",[t._v("定期扫描")])]),t._v(" "),e("blockquote",[e("p",[t._v("如何保证存的都是热点数据?")]),t._v(" "),e("ul",[e("li",[t._v("redis内存数据集上升到一定值（maxmemory）会进行淘汰策略淘汰。")]),t._v(" "),e("li",[t._v("需要选择基于LRU算法的淘汰策略（volatile-lru，allkeys-lru）")])])]),t._v(" "),e("h2",{attrs:{id:"应用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[t._v("#")]),t._v(" 应用场景")]),t._v(" "),e("ol",[e("li",[t._v("热点数据缓存")]),t._v(" "),e("li",[t._v("自增id生成（计数器）")]),t._v(" "),e("li",[t._v("限时业务处理（分布式锁）")]),t._v(" "),e("li",[t._v("消息队列")]),t._v(" "),e("li",[t._v("热门列表和排行表")]),t._v(" "),e("li",[t._v("访问频率控制")])]),t._v(" "),e("h4",{attrs:{id:"分布式锁的实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁的实现"}},[t._v("#")]),t._v(" 分布式锁的实现")]),t._v(" "),e("ol",[e("li",[t._v("使用setnx来获取锁，设置expire参数加过期时间\n"),e("ul",[e("li",[t._v("redis支持原子操作 "),e("code",[t._v("SET key value EX seconds NX")]),t._v("（只适合单机）")])])]),t._v(" "),e("li",[t._v("集群情况下，slave获取同步锁信息前，master挂掉，slaver晋升为master，此时会丢失锁，使用redLock\n"),e("ul",[e("li",[t._v("前提：5个redis实例（哨兵机制的话会比较复杂，脑裂问题）")]),t._v(" "),e("li",[t._v("获取当前实例unix时间，ms为单位")]),t._v(" "),e("li",[t._v("依次尝试从5个实例中获取锁，如果在响应超时时间内获取失败则失败，响应超时时间(5-10ms)应远小于锁失效时间（10s），如果获取成功，key真正有效时间 = 锁失效时间 - 获取锁耗时")]),t._v(" "),e("li",[t._v("当且仅当从大多数实例（n/2+1）取得锁，并时间少于锁失效时间，锁才算获取成功")]),t._v(" "),e("li",[t._v("如果因为某些原因获取锁失败（没有得到大多数，或超过有效时间）则应在所有实例上进行解锁（即便某些实例根本没有获取锁成功，防止某些节点已经获取锁只是没有来得及响应而被判断失败，导致在锁是失效内一致都不能获取锁）"),e("a",{attrs:{href:"https://mp.weixin.qq.com/s/JLEzNqQsx-Lec03eAsXFOQ",target:"_blank",rel:"noopener noreferrer"}},[t._v("Redlock：Redis分布式锁最牛逼的实现"),e("OutboundLink")],1)])])])]),t._v(" "),e("blockquote",[e("p",[t._v("redis分布式锁性能高，zookeeper分布式锁健壮性更优")])]),t._v(" "),e("h4",{attrs:{id:"分布式限流的实现-1小时能只能登陆5次"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式限流的实现-1小时能只能登陆5次"}},[t._v("#")]),t._v(" 分布式限流的实现(1小时能只能登陆5次)")]),t._v(" "),e("blockquote",[e("p",[t._v("使用zset实现滑动窗口限流，key value score")])]),t._v(" "),e("ol",[e("li",[t._v("使用用户id+操作行为作为key")]),t._v(" "),e("li",[t._v("使用时间戳作为score,添加到set中")]),t._v(" "),e("li",[t._v("移除score 处于0到（当前时间戳-滑动周期）中的value")]),t._v(" "),e("li",[t._v("统计该key所有的数量，设置当前key的过期时间为周期+1s（防止网络延迟）")])]),t._v(" "),e("div",{staticClass:"language-java line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//拷贝自 http://svip.iocoder.cn/Redis/Interview/#Redis")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("isActionAllowed")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" userId"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" actionKey"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" period"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" maxCount"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" key "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("format")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hist:%s:%s"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" userId"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" actionKey"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用用户编号 + 行为作为 KEY 。这样，我们就可以统计某个用户的操作行为。")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" nowTs "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("currentTimeMillis")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 获取当前时间。")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Pipeline")]),t._v(" pipe "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" jedis"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("pipelined")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// pipeline 批量操作，提升效率。")]),t._v("\n    pipe"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("multi")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 此处启动了事务，可以保证指令的原子性。")]),t._v("\n    pipe"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("zadd")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" nowTs"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('""')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" nowTs"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// zset 添加，key value score 要看下。")]),t._v("\n    pipe"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("zremrangeByScore")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" nowTs "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("period "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// zremrangeByScore ，移除超过周期的 value 。")]),t._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Response")]),e("span",{pre:!0,attrs:{class:"token generics"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Long")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" count "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" pipe"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("zcard")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// zcard ，计算 zset 的数量")]),t._v("\n    pipe"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("expire")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" period "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设置过期。这里多 + 1 秒，为了防止网络延迟。")]),t._v("\n    pipe"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("exec")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// pipeline 执行")]),t._v("\n    pipe"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("close")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" count"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" maxCount"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 是否超过最大次数。")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br"),e("span",{staticClass:"line-number"},[t._v("15")]),e("br"),e("span",{staticClass:"line-number"},[t._v("16")]),e("br"),e("span",{staticClass:"line-number"},[t._v("17")]),e("br")])]),e("h4",{attrs:{id:"实现消息队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现消息队列"}},[t._v("#")]),t._v(" 实现消息队列")]),t._v(" "),e("ol",[e("li",[t._v("使用list结构作为队列，rpush生产消息，lpop消费，缺点是不会等待有消息才消费，会一直消费，可以引入sleep机制去调用lpop重试")]),t._v(" "),e("li",[t._v("也可以使用blpop key timeout，会阻塞队列直到有消息或者超时，缺点是只能供一个消费者消费")]),t._v(" "),e("li",[t._v("使用pub/sub主题订阅模式可以实现1:N的消费队列，缺点是发布是无状态，无法保证到达，消息即发即逝，所以消费者下线情况下会丢失消息")])]),t._v(" "),e("h3",{attrs:{id:"redis事务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis事务"}},[t._v("#")]),t._v(" redis事务")]),t._v(" "),e("ol",[e("li",[t._v("事务所有命令都会被串行化执行")]),t._v(" "),e("li",[t._v("事务开启后失败不会回滚，会继续执行")]),t._v(" "),e("li",[t._v("MULTI/EXEC/DISCARD/WATCH 实现事务的命令")]),t._v(" "),e("li",[t._v("通过watch命令可以实现CAS")])]),t._v(" "),e("h2",{attrs:{id:"集群相关"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#集群相关"}},[t._v("#")]),t._v(" 集群相关")]),t._v(" "),e("h3",{attrs:{id:"集群方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#集群方案"}},[t._v("#")]),t._v(" 集群方案")]),t._v(" "),e("h3",{attrs:{id:"主从同步原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#主从同步原理"}},[t._v("#")]),t._v(" 主从同步原理")]),t._v(" "),e("ul",[e("li",[t._v("支持主从复制（单向流动）和从从复制（新增）")]),t._v(" "),e("li",[t._v("主节点挂了，从节点提供服务，保证高可用")]),t._v(" "),e("li",[t._v("读写分离，主读写，从只读，一个从只能有一个主")]),t._v(" "),e("li",[t._v("第一次同步，主做bgsave操作，同时把后续修改先记录到内存buffer中，等数据快照同步到slave后再将期间的操作记录回放到复制节点")])]),t._v(" "),e("p",[t._v("主从同步的弊端是不具备高可用，因为master挂掉后，redis将不能提供写入操作，所以有了哨兵机制")]),t._v(" "),e("p",[t._v("哨兵机制（redis Sentinel），本身也是一个独立运行的进程\n"),e("img",{attrs:{src:a(422),alt:"哨兵架构图"}})]),t._v(" "),e("ul",[e("li",[t._v("哨兵有一个节点或多个节点组成，特殊的节点不存储数据")]),t._v(" "),e("li",[t._v("主节点和从节点都属于数据节点\n功能：\n"),e("ul",[e("li",[t._v("监控+自动故障转移（选取新的主节点）")]),t._v(" "),e("li",[t._v("配置提供（提供数据节点地址）+通知（故障转移结果）")]),t._v(" "),e("li",[t._v("转移的规则\n"),e("ul",[e("li",[t._v("淘汰ping时间超过5s")]),t._v(" "),e("li",[t._v("淘汰超过连接时间阈值的")]),t._v(" "),e("li",[t._v("选取复制偏移量最大的，同等下选id最小的机器")])])])])])]),t._v(" "),e("h3",{attrs:{id:"redis集群原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis集群原理"}},[t._v("#")]),t._v(" redis集群原理")]),t._v(" "),e("p",[e("img",{attrs:{src:a(423),alt:""}}),t._v("\n背景：如何在海量数据中快速查找所需要的数据")]),t._v(" "),e("ol",[e("li",[t._v("无中心结构，每个节点保存数据和整个集群的状态，每个节点都和所有节点连接")]),t._v(" "),e("li",[t._v("使用gossip协议（流言协议，反熵思想）传播信息以及发现新的节点")]),t._v(" "),e("li",[t._v("数据分片，通过hash()函数去对节点数求模，以达到均匀分布的目标，缺点是不可以动态调整节点数\n"),e("ul",[e("li",[t._v("解决方案：\n"),e("ul",[e("li",[t._v("一致性哈希算法，对2^32求模（哈希算法返回int整数类型，32位），将哈希值空间组织成虚拟的圆环，0-2^32-1")]),t._v(" "),e("li",[t._v("数据根据一样的哈希函数运算后求模，顺时针第一台服务器就是目标存储服务器")]),t._v(" "),e("li",[t._v("对于节点的增减都只需要重新定位一小部分的数据，具有较好容错性和扩展性")]),t._v(" "),e("li",[t._v("缺点是：数据倾斜问题，数据不是均匀分布。（解决方法引入虚拟节点解决数据倾斜问题。将虚拟节点平均分在圆环上，对虚拟节点进行映射）")])])])])])]),t._v(" "),e("h3",{attrs:{id:"redis6-0新特性-多线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis6-0新特性-多线程"}},[t._v("#")]),t._v(" redis6.0新特性--多线程")]),t._v(" "),e("ol",[e("li",[t._v("之前的版本也不是完全单线程，除了主线程，也有后台线程在处理一些缓慢的操作。")]),t._v(" "),e("li",[t._v("redis瓶颈主要在于网络的IO消耗，利用多线程分摊IO读写负荷")]),t._v(" "),e("li",[t._v("不会存在并发问题，应为多线程部分只是用于处理网络数据的读写和协议的解析，命令执行依旧是单线程顺序执行。")])]),t._v(" "),e("blockquote",[e("p",[e("strong",[e("a",{attrs:{href:"https://mp.weixin.qq.com/s/f9N13fnyTtnu2D5sKZiu9w",target:"_blank",rel:"noopener noreferrer"}},[t._v("面试好文"),e("OutboundLink")],1)])]),t._v(" "),e("p",[e("strong",[e("RouterLink",{attrs:{to:"/docs/server/分布式锁.html"}},[t._v("分布式锁的应用")])],1)]),t._v(" "),e("p",[e("strong",[e("a",{attrs:{href:"https://blog.csdn.net/zyhlwzy/article/details/90721481",target:"_blank",rel:"noopener noreferrer"}},[t._v("spring-data-redis实现简单分布式（秒杀示例）"),e("OutboundLink")],1)])])]),t._v(" "),e("h2",{attrs:{id:"应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#应用"}},[t._v("#")]),t._v(" 应用")]),t._v(" "),e("h3",{attrs:{id:"查询固定前缀的key"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#查询固定前缀的key"}},[t._v("#")]),t._v(" 查询固定前缀的key")]),t._v(" "),e("blockquote",[e("p",[t._v("从海量key中查询某一固定前缀的key（得看数据量）")])]),t._v(" "),e("ul",[e("li",[t._v("keys pattern:keys指令查找匹配的key\n"),e("ul",[e("li",[t._v("一次性返回，阻塞")])])]),t._v(" "),e("li",[t._v("scan cursor [MATCH pattern] [COUNT count]\n"),e("ul",[e("li",[t._v("非阻塞，游标从0到0返回作为一次完整的查询")]),t._v(" "),e("li",[t._v("指定数据返回的范围，每次返回数据量不一定等于指定值，通过游标分多次查询")]),t._v(" "),e("li",[t._v("获取的游标不一定一直递增，所以有重复数据，需要在外部逻辑去重处理")])])])]),t._v(" "),e("h3",{attrs:{id:"开发工具"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#开发工具"}},[t._v("#")]),t._v(" 开发工具")]),t._v(" "),e("ul",[e("li",[t._v("Jedis：对Redis命令的封装，通过java连接redis的工具包，提供redis各种命令支持 "),e("strong",[t._v("api")])]),t._v(" "),e("li",[t._v("spring-data-redis：spring对redis的整合，对redis底层"),e("strong",[t._v("开发包(jedis/Lettuce)进行了高度封装")]),t._v("，RedisTemplate提供了redis各种操作\n"),e("ul",[e("li",[t._v("2.0版本之前setnx和expire两个命令非原子性")]),t._v(" "),e("li",[t._v("2.0版本之后，Redis通过set(key,value,expire)命令，将setnx和expire两个命令合并为一个原子操作")]),t._v(" "),e("li",[t._v("对于耗时的业务需要开启一个守护线程（new Thead().setDaemon(true)），定时给锁续约")]),t._v(" "),e("li",[t._v("单机模式（指redis）下CP模型，集群模式下AP模型，需要redLock等算法保证分布式锁")])])]),t._v(" "),e("li",[t._v("redLock：分布式锁的一种实现"),e("strong",[t._v("算法")]),t._v("，用于多节点redis实现分布式锁")]),t._v(" "),e("li",[t._v("Redisson：在redis基础上，基于netty通讯的客户端，有一整套成熟的"),e("strong",[t._v("分布式解决方案")]),t._v("，自动续约（每1/3的超时时间触发）和redLock的实现")])]),t._v(" "),e("h3",{attrs:{id:"redis常见问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis常见问题"}},[t._v("#")]),t._v(" redis常见问题")]),t._v(" "),e("ol",[e("li",[t._v("master最好不要做持久化，特别是内存快照持久化")]),t._v(" "),e("li",[t._v("主从最好在同一个局域网内")]),t._v(" "),e("li",[t._v("避免在压力较大的主库上增加从库")]),t._v(" "),e("li",[t._v("为了master稳定性，主从复制不要使用图状结构，而是单向链表更稳定，替换也更快")]),t._v(" "),e("li",[t._v("快速找出redis上以某个固定值作为前缀的key，keys指令最快但阻塞，scan指令无阻塞，但慢点有一定概率重复性，可以客户端再做去重处理。")])])])}),[],!1,null,null,null);s.default=r.exports}}]);