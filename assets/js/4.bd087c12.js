(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{430:function(t,v,_){t.exports=_.p+"assets/img/image-20220511171901638.f0d9206b.png"},431:function(t,v,_){t.exports=_.p+"assets/img/image-20220511171919875.8e8b8b5a.png"},432:function(t,v,_){t.exports=_.p+"assets/img/image-20220511171938037.9f8e7e92.png"},433:function(t,v,_){t.exports=_.p+"assets/img/image-20220511172001030.c7af27f3.png"},434:function(t,v,_){t.exports=_.p+"assets/img/image-20220511172009269.ad88c6b3.png"},435:function(t,v,_){t.exports=_.p+"assets/img/image-20220511172018613.06e06523.png"},436:function(t,v,_){t.exports=_.p+"assets/img/image-20220511172034851.e1e0e836.png"},437:function(t,v,_){t.exports=_.p+"assets/img/image-20220511172042421.79b86515.png"},438:function(t,v,_){t.exports=_.p+"assets/img/image-20220511172050678.d2bad2dc.png"},487:function(t,v,_){"use strict";_.r(v);var a=_(33),e=Object(a.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"jvm内存结构剖析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm内存结构剖析"}},[t._v("#")]),t._v(" JVM内存结构剖析")]),t._v(" "),a("p",[a("strong",[t._v("堆内存区")])]),t._v(" "),a("p",[t._v("用于存储Java对象的区域，也是GC收集器回收的主要区域")]),t._v(" "),a("p",[a("strong",[t._v("方法区")])]),t._v(" "),a("p",[t._v("主要存储静态变量，静态引用，常量，以及C++层元数据的区域")]),t._v(" "),a("p",[a("strong",[t._v("虚拟机栈")])]),t._v(" "),a("p",[t._v("用与存储方法调用栈，以及保存方法调用过程当中生成的局部变量和局部引用")]),t._v(" "),a("p",[a("strong",[t._v("本地方法栈")])]),t._v(" "),a("p",[t._v("保存java native方法调用栈的地方")]),t._v(" "),a("p",[a("strong",[t._v("程序计数器")])]),t._v(" "),a("p",[t._v("存储代码执行的行号")]),t._v(" "),a("p",[a("img",{attrs:{src:_(430),alt:"image-20220511171901638"}})]),t._v(" "),a("p",[a("strong",[t._v("线程共享")])]),t._v(" "),a("p",[t._v("这部分每次区域为线程之间共享访问，多线程访问时要注意并发安全")]),t._v(" "),a("p",[a("strong",[t._v("线程独占")])]),t._v(" "),a("p",[t._v("这部分区域由线程独占，如果线程数过多，会造成这部分内存消耗过大")]),t._v(" "),a("p",[a("strong",[t._v("问答区：")])]),t._v(" "),a("p",[t._v("问：我创建的局部对象存储在哪个区域？")]),t._v(" "),a("p",[t._v("答：对象一律在堆内存区，但是这个对象的引用(指向这个对象的指针)在栈内存区")]),t._v(" "),a("p",[t._v("问：Class对象在方法区吗？")]),t._v(" "),a("p",[t._v("答：不准确，Class对象仍然在堆内存区域，只是方法区有这个Class对象的引用")]),t._v(" "),a("p",[t._v("问：全局String常量在方法区吗？")]),t._v(" "),a("p",[t._v("答：不准确，String仍然是对象，对象就在堆内存区，方法区的字符串常量池持有它的一个引用")]),t._v(" "),a("h2",{attrs:{id:"_1-1-堆内存区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-堆内存区"}},[t._v("#")]),t._v(" 1.1 堆内存区")]),t._v(" "),a("p",[t._v("堆内存结构和GC收集器相关，通常经典收集器下(串行收集器/并行收集器/CMS收集器)，将内存划分为如下区域：")]),t._v(" "),a("p",[a("strong",[t._v("新生代")])]),t._v(" "),a("p",[t._v("用于存放刚创建的对象")]),t._v(" "),a("p",[a("strong",[t._v("eden")])]),t._v(" "),a("p",[t._v("新创建对象会直接分片在这块区域内")]),t._v(" "),a("p",[a("strong",[t._v("s0,s1")])]),t._v(" "),a("p",[t._v("youngGC基于复制回收算法，s0,s1主要保存每次youngGC之后的存活对象")]),t._v(" "),a("p",[a("strong",[t._v("老年代")])]),t._v(" "),a("p",[t._v("存放长时间存活的对象")]),t._v(" "),a("p",[a("img",{attrs:{src:_(431),alt:"image-20220511171919875"}})]),t._v(" "),a("p",[t._v("为什么要设计分代回收呢？")]),t._v(" "),a("p",[a("strong",[t._v("GC分代收集理论")])]),t._v(" "),a("ol",[a("li",[t._v("弱分代假说：绝大多数对象的生命周期都很短，绝大多数的对象都是朝生夕灭的。")]),t._v(" "),a("li",[t._v("强分代假说：熬过越多次垃圾收集过程的对象越难以消亡")]),t._v(" "),a("li",[t._v("跨代引用假说：跨代引用相对于同代引用来说仅占极少数")])]),t._v(" "),a("p",[t._v("如果一个区域里全都是新创建的对象，根据弱分代假说，这些对象里的绝大多数很快将消亡，需要被频繁回收。")]),t._v(" "),a("p",[t._v("针对这部分对象Jvm将它们划分到年轻代，并采用牺牲可用内存并提升回收效率的"),a("strong",[t._v("复制清除算法")]),t._v("。")]),t._v(" "),a("p",[t._v("而长期存活的对象，回收频率低。Jvm将这些对象晋升到老年代，并采用比较耗时但内存利用率高的"),a("strong",[t._v("标记整理算法/标记清除算法")])]),t._v(" "),a("p",[t._v("同时基于跨代引用假说，跨代引用占比极少，所以划分少量内存，采用"),a("strong",[t._v("记忆集/卡表")]),t._v("的方式保存跨代引用")]),t._v(" "),a("h3",{attrs:{id:"gc标记算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gc标记算法"}},[t._v("#")]),t._v(" GC标记算法")]),t._v(" "),a("p",[a("strong",[t._v("可达性分析算法")])]),t._v(" "),a("p",[t._v("将“GC Roots” 对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为非垃圾对象，其余未标记的对象都是垃圾对象")]),t._v(" "),a("p",[a("strong",[t._v("GC Roots")]),t._v("：线程栈的本地变量、静态变量、本地方法栈的变量等等")]),t._v(" "),a("p",[a("img",{attrs:{src:_(432),alt:"image-20220511171938037"}})]),t._v(" "),a("h3",{attrs:{id:"常见gc收集算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见gc收集算法"}},[t._v("#")]),t._v(" 常见GC收集算法")]),t._v(" "),a("p",[a("strong",[t._v("复制清除算法")])]),t._v(" "),a("p",[a("img",{attrs:{src:_(433),alt:"image-20220511172001030"}})]),t._v(" "),a("p",[t._v("缺点：牺牲部分可用内存，并发不安全")]),t._v(" "),a("p",[a("strong",[t._v("标记整理算法")])]),t._v(" "),a("p",[a("img",{attrs:{src:_(434),alt:"image-20220511172009269"}})]),t._v(" "),a("p",[t._v("缺点：效率低，并发不安全")]),t._v(" "),a("p",[a("strong",[t._v("标记清除算法")])]),t._v(" "),a("p",[a("img",{attrs:{src:_(435),alt:"image-20220511172018613"}})]),t._v(" "),a("p",[t._v("缺点：造成内存碎片")]),t._v(" "),a("h3",{attrs:{id:"记忆集与卡表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#记忆集与卡表"}},[t._v("#")]),t._v(" 记忆集与卡表")]),t._v(" "),a("p",[a("strong",[t._v("记忆集")])]),t._v(" "),a("p",[t._v("当我们进行young gc时，如果老年代有对象引用了我们的新生代对象，那么老年代的对象也应该加入gc roots的范围中，但是如果每次进行young gc我们都需要扫描一次老年代的话，那我们进行垃圾回收的代价实在是太大了。")]),t._v(" "),a("p",[t._v("所以JVM设计者做了这样的设计，用记忆集记录从老年代指向新生代的指针的集合。")]),t._v(" "),a("p",[a("strong",[t._v("卡表")])]),t._v(" "),a("p",[t._v("HotSpot JVM，使用了卡标记（Card Marking）技术来解决老年代到新生代的引用问题。具体是，使用卡表（Card Table）和写屏障（Write Barrier）来进行标记并加快对GC Roots的扫描。")]),t._v(" "),a("p",[t._v("卡表是使用一个字节数组实现：CARD_TABLE[ ]，每个元素对应着其标识的内存区域一块特定大小的内存块，称为“卡页”。")]),t._v(" "),a("p",[t._v("hotSpot使用的卡页是2^9大小，即512byte。卡页的内存指的是老年代区域内存。")]),t._v(" "),a("p",[a("img",{attrs:{src:_(436),alt:"image-20220511172034851"}})]),t._v(" "),a("p",[t._v("每个卡页中间可能存在多个老年代对象，一旦这些对象有对新生代的引用，这个卡页会变成“脏页”，对应的字节数组元素的值变为1。")]),t._v(" "),a("p",[t._v("当发生young GC时，将脏页中所有元素加入gc root。")]),t._v(" "),a("p",[a("strong",[t._v("卡表的维护")])]),t._v(" "),a("p",[t._v("如何让卡表“变脏”，就需要在对应的引用赋值时，将相应的卡表设置成1。")]),t._v(" "),a("p",[t._v("Hotspot使用"),a("strong",[t._v("写屏障")]),t._v("维护卡表状态。")]),t._v(" "),a("p",[a("strong",[t._v("问答区：")])]),t._v(" "),a("p",[t._v("问：内存碎片有什么影响？")]),t._v(" "),a("p",[t._v("答：分配对象需要连续内存，碎片过多会导致难以分配大对象")]),t._v(" "),a("p",[t._v("问：年轻代复制清除时S0/S1空间不够保存存活的对象怎么办？")]),t._v(" "),a("p",[t._v("答：jvm有动态年龄晋升机制，会提前将一部分年龄较大对象晋升到老年代，从而避免出现这种问题")]),t._v(" "),a("p",[t._v("问：老年代空间不够用怎么办？")]),t._v(" "),a("p",[t._v("答：分配对象前会先FullGC，如果还不够会抛出OOM异常")]),t._v(" "),a("p",[t._v("问：写屏障是什么？")]),t._v(" "),a("p",[t._v("答：后面章节会讲")]),t._v(" "),a("h2",{attrs:{id:"_1-2-虚拟机栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-虚拟机栈"}},[t._v("#")]),t._v(" 1.2 虚拟机栈")]),t._v(" "),a("p",[t._v("栈内存区和数据结构栈相识，每个线程一个栈，栈内元素由栈帧组成。")]),t._v(" "),a("p",[a("strong",[t._v("栈帧")])]),t._v(" "),a("p",[t._v("栈帧随着方法的调用而创建，随着方法的结束而销毁。方法的结束无论是正常结束，还是异常结束，都算方法的结束。")]),t._v(" "),a("p",[t._v("栈帧是一种数据结构，由本地变量表、操作数栈、动态链接、方法出口组成。")]),t._v(" "),a("p",[a("img",{attrs:{src:_(437),alt:"image-20220511172042421"}})]),t._v(" "),a("p",[a("strong",[t._v("本地变量表")])]),t._v(" "),a("p",[t._v("本地变量表存放了编译期可知方法的各种局部变量，可以有基本数据类型和对象引用。")]),t._v(" "),a("p",[a("strong",[t._v("操作数栈")])]),t._v(" "),a("p",[t._v("操作数栈是方法执行字节码期间的辅助栈结构。例如如下代码：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("a=b+c;\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("编译成class字节码如下:")]),t._v(" "),a("ol",[a("li",[t._v("iload_2  #将本地变量表位置2的变量压入操作数栈")]),t._v(" "),a("li",[t._v("iload_3  #将本地变量表位置3的变量压入操作数栈")]),t._v(" "),a("li",[t._v("iadd    #对操作数栈执行相加指令")]),t._v(" "),a("li",[t._v("istore_1 #将栈内结果保存到本地变量表位置1中")])]),t._v(" "),a("p",[t._v("栈深度在编译期间就可以确定")]),t._v(" "),a("p",[a("strong",[t._v("动态连接")])]),t._v(" "),a("p",[t._v("class文件中对方法的引用都是符号引用(以字符串常量的形式保存方法名)，但是调用的时候需要转化成直接引用(c++中指向函数的指针)，这样调用的时候才能直接调用对应函数。将符号引用转化为直接引用的过程称为动态连接。")]),t._v(" "),a("p",[a("strong",[t._v("方法出口")])]),t._v(" "),a("p",[t._v("指向方法结束地址的指针")]),t._v(" "),a("h1",{attrs:{id:"_2-相关jvm参数介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-相关jvm参数介绍"}},[t._v("#")]),t._v(" 2.相关JVM参数介绍")]),t._v(" "),a("p",[a("strong",[t._v("堆内存区")])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"left"}},[t._v("名称")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("参数")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("说明")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("堆内存初始大小")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("-Xms2g")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("堆内存初始大小建议和最大值设置一致，不然在扩容过程中会触发fullGC")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("堆内存最大值")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("-Xmx2g")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}})]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("新生代比例")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("-XX:NewRatio=2")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("设置2表示新生代和老年代比例为1:2")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("Survivor区比例")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("-XX:SurvivorRatio=8")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("设置8表示S0或S1与Eden比例为1:8")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("新生代大小")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("-Xmn1g")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("直接设置新生代大小，优先级比-XX:NewRatio高")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("对象晋升年龄")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("-XX:MaxTenuringThreshold")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("设置对象晋升时的年龄大小，最大为15")])])])]),t._v(" "),a("p",[a("strong",[t._v("方法区")])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"left"}},[t._v("名称")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("参数")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("说明")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("永久代初始大小")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("-XX:PermSize=64M")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("设置永久代空间初始大小（1.7以上弃用）")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("永久代最大值")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("-XX:MaxPermSize=128M")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("1.7以上弃用")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("元空间初始化大小")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("-XX:MetaspaceSize=256m")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("推荐设置，否则jdk可能会动态扩容，每次扩容会导致fullGC")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("元空间最大值")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("-XX:MaxMetaspaceSize=256m")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("推荐初始大小和最大值设置一致，避免扩容导致的fullGC")])])])]),t._v(" "),a("p",[a("strong",[t._v("栈内存区")])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"left"}},[t._v("名称")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("参数")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("说明")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("栈内存大小")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("-Xss128k")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("如果设置太大，系统可创建线程数就会变少。如果设置太少，方法太深的时候会栈溢出。")])])])]),t._v(" "),a("h1",{attrs:{id:"_3-参数配置原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-参数配置原则"}},[t._v("#")]),t._v(" 3.参数配置原则")]),t._v(" "),a("p",[t._v("JVM参数配置主要是为了保证系统可靠性的基础上，尽可能的减少FullGC")]),t._v(" "),a("h3",{attrs:{id:"元空间设置固定值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#元空间设置固定值"}},[t._v("#")]),t._v(" 元空间设置固定值")]),t._v(" "),a("p",[t._v("-XX:MetaspaceSize以及-XX:MaxMetaspaceSize设置相同的固定值，容量保证可以让服务启动。")]),t._v(" "),a("p",[t._v("如果不设置，元空间大小会随着使用自动扩容，扩容的同时会导致FullGC")]),t._v(" "),a("h3",{attrs:{id:"堆内存设置固定值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#堆内存设置固定值"}},[t._v("#")]),t._v(" 堆内存设置固定值")]),t._v(" "),a("p",[t._v("-Xms2g以及-Xmx2g设置相同的固定值，保证系统使用中用足够的运行内存。")]),t._v(" "),a("p",[t._v("如果不设置，对内存扩容的过程中，会导致FullGC")]),t._v(" "),a("h3",{attrs:{id:"栈内存设置不要太大"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈内存设置不要太大"}},[t._v("#")]),t._v(" 栈内存设置不要太大")]),t._v(" "),a("p",[t._v("-Xss可以设置128k，如果设置太大，会导致可用线程数变少")]),t._v(" "),a("h3",{attrs:{id:"尽可能让朝生夕死的对象保留在新生代"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#尽可能让朝生夕死的对象保留在新生代"}},[t._v("#")]),t._v(" 尽可能让朝生夕死的对象保留在新生代")]),t._v(" "),a("p",[t._v("由于新生代GC耗时远小于FullGC，所以尽可能让对象早早的就在新生代被清理掉。")]),t._v(" "),a("p",[t._v("首先根据预定的性能指标进行压测，通过压测工具知道内存增长速度。")]),t._v(" "),a("p",[t._v("通过设置-Xmn适当增加新生代大小，保证新增对象能在新生代能正常回收。而不进入老年代。")]),t._v(" "),a("p",[t._v("如果有朝生夕死的对象晋升到老年代，由于这些对象使用后都成了垃圾对象，堆满之后会造成老年代的FullGC。")]),t._v(" "),a("p",[t._v("新生代大小不要过大，否则会基于"),a("strong",[t._v("老年代空间担保机制")]),t._v("，导致MinnorGC之前会触发FullGC。")]),t._v(" "),a("p",[a("img",{attrs:{src:_(438),alt:"image-20220511172050678"}})])])}),[],!1,null,null,null);v.default=e.exports}}]);