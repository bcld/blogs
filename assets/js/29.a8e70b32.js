(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{485:function(t,s,a){"use strict";a.r(s);var e=a(33),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"tcp相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp相关"}},[t._v("#")]),t._v(" TCP相关")]),t._v(" "),a("blockquote",[a("p",[a("a",{attrs:{href:"https://www.cnblogs.com/JHCan333/p/11808674.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("三次握手和四次挥手以及TCP标志位的详细介绍 "),a("OutboundLink")],1)])]),t._v(" "),a("h2",{attrs:{id:"标志位"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标志位"}},[t._v("#")]),t._v(" 标志位")]),t._v(" "),a("ol",[a("li",[t._v("SYN：发送同步标识，建立连接时使用")]),t._v(" "),a("li",[t._v("ACK：确认标识，表示收到请求")]),t._v(" "),a("li",[t._v("PSH：推送操作，不进入队列等候，尽快交给程序处理")]),t._v(" "),a("li",[t._v("FIN：结束标识，用于结束一个TCP回话")]),t._v(" "),a("li",[t._v("RST：重置复位标识")]),t._v(" "),a("li",[t._v("URG：紧急标识，保证TCP连接不能被中断，且敦促中间层尽快处理")])]),t._v(" "),a("h2",{attrs:{id:"三次握手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[t._v("#")]),t._v(" 三次握手")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://image.135editor.com/files/users/749/7492441/201911/9s7eBDgK_XqV8.png",alt:"img"}})]),t._v(" "),a("ul",[a("li",[t._v("第一次握手：客户端主动发送标志位SYN=1,seq=x(随机生成)的数据包给服务器，客户端处于sync_wait状态")]),t._v(" "),a("li",[t._v("第二次握手：服务端收到后发送标志为SYN=1,ACK =1,seq= y，ack=x+1的数据返回给客户端，处于sync_wait状态")]),t._v(" "),a("li",[t._v("第三次握手：客户端收到后发送标志位ACK=1，seq=x+1，ack=y+1的数据包给服务端，处于establish状态，服务端收到校验ack值后也处于establish状态")])]),t._v(" "),a("h3",{attrs:{id:"为什么不能两次握手完成连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么不能两次握手完成连接"}},[t._v("#")]),t._v(" 为什么不能两次握手完成连接？")]),t._v(" "),a("p",[t._v("如果第二次握手，服务端发送确认报文后，由于网络原因，客户端一直没收到且不知道seq号，那么客户端一直在等待确认，而服务端以为建立连接成功，就会尝试发送消息，结果一直没收到客户端的回复，就会重复发送消息。")]),t._v(" "),a("h2",{attrs:{id:"四次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[t._v("#")]),t._v(" 四次挥手")]),t._v(" "),a("blockquote",[a("p",[t._v("双方初始状态都处于establish")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://image.135editor.com/files/users/749/7492441/201911/O2bTZ8HU_Whar.png",alt:"img"}})]),t._v(" "),a("ul",[a("li",[t._v("第一次挥手：客户端发出释放报文，FIN=1,seq=u（之前连接的最后一个字节序号+1）客户端进入FIN-WAIT-1阶段")]),t._v(" "),a("li",[t._v("第二次挥手：服务端收到请求后，发出确认报文，ACK =1 ,ack=u+1，seq= v，进入close-wait状态")]),t._v(" "),a("li",[t._v("第三次挥手：客户端收到确认请求后，进入fin-wait-2阶段，等待服务器将最后的数据发送完毕后，就会向客户端发送连续释放报文FIN=1,ACK=1,seq=w，ack= v+1")]),t._v(" "),a("li",[t._v("第四次挥手：客户端收到后，发出确认报文，ACK=1，ack=w+1，进入TIME-WAIT状态，TCP连接需要经过2MSL后，才会进入closed关闭状态，同时服务端收到确认报文后也会进入closed状态")])]),t._v(" "),a("h3",{attrs:{id:"为什么要等待2msl"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要等待2msl"}},[t._v("#")]),t._v(" 为什么要等待2MSL")]),t._v(" "),a("p",[t._v("MSL是TCP协议中任何报文在网络中最大的生存时间，超过这个时间的数据都会被丢弃，确保最后一次ack能够送到。客户端发出ACK报文到服务器端的最大时间 + 服务器没有接收到ACK报文再次发出FIN的最大时间 = 2MSL")])])}),[],!1,null,null,null);s.default=r.exports}}]);