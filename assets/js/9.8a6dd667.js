(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{443:function(t,a,r){t.exports=r.p+"assets/img/commonRW.96bf4c7c.jpg"},444:function(t,a,r){t.exports=r.p+"assets/img/mmap.d946010c.png"},445:function(t,a,r){t.exports=r.p+"assets/img/sendfile.7040097d.jpg"},493:function(t,a,r){"use strict";r.r(a);var e=r(33),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"消息中间件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#消息中间件"}},[t._v("#")]),t._v(" 消息中间件")]),t._v(" "),e("blockquote",[e("p",[t._v("参考:"),e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/163759210",target:"_blank",rel:"noopener noreferrer"}},[t._v("Kafka和RocketMQ底层存储之那些你不知道的事"),e("OutboundLink")],1)])]),t._v(" "),e("h2",{attrs:{id:"常用消息中间件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常用消息中间件"}},[t._v("#")]),t._v(" 常用消息中间件")]),t._v(" "),e("p",[e("RouterLink",{attrs:{to:"/docs/server/RocketMq初认识.html"}},[t._v("rocketMq初认识")])],1),t._v(" "),e("p",[e("RouterLink",{attrs:{to:"/docs/server/kafka初认识.html"}},[t._v("kafka初认识")])],1),t._v(" "),e("h2",{attrs:{id:"比较"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#比较"}},[t._v("#")]),t._v(" 比较")]),t._v(" "),e("h3",{attrs:{id:"底层存储方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#底层存储方式"}},[t._v("#")]),t._v(" 底层存储方式")]),t._v(" "),e("p",[e("strong",[t._v("磁盘")]),t._v(":外部存储器的介质,磁盘通过顺序读写可以实现高吞吐.")]),t._v(" "),e("p",[e("strong",[t._v("页缓存")]),t._v("page cache:磁盘的一种缓存,减少I/O次数")]),t._v(" "),e("ul",[e("li",[t._v("写入的时候其实是写到页缓存中,小写合并成大写后刷盘,即后写,避免断电导致未刷盘的"),e("strong",[t._v("脏页")]),t._v("丢失,可以使用fsync强制刷盘,性能损耗较大")]),t._v(" "),e("li",[t._v("读会预读,会把相邻的磁盘读入页缓存中.")]),t._v(" "),e("li",[t._v("一般建议多副本机制保证消息可靠,而不是同步刷盘")])]),t._v(" "),e("p",[e("strong",[t._v("mmap")]),t._v(":文件映射,将程序虚拟页面直接映射到页缓存上，这样就无需有内核态再往用户态的拷贝，而且也避免了重复数据的产生")]),t._v(" "),e("p",[e("strong",[t._v("DMA")]),t._v(":全称 Direct Memory Access ，它可以独立地直接读写系统内存，不需要 CPU 介入，像显卡、网卡之类都会用DMA")]),t._v(" "),e("h4",{attrs:{id:"普通读写流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#普通读写流程"}},[t._v("#")]),t._v(" 普通读写流程")]),t._v(" "),e("p",[t._v("4次上下文切换+2次拷贝(3个地方-缓冲区\\页缓存\\socket Buffer)\n"),e("img",{attrs:{src:r(443),alt:""}})]),t._v(" "),e("h4",{attrs:{id:"mmap读写-mmap-write"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mmap读写-mmap-write"}},[t._v("#")]),t._v(" mmap读写(mmap+write)")]),t._v(" "),e("p",[t._v("4次上下文切换+1次拷贝(2个地方-页缓存\\socket Buffer)\n"),e("img",{attrs:{src:r(444),alt:""}})]),t._v(" "),e("h4",{attrs:{id:"sendfile-linux2-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sendfile-linux2-4"}},[t._v("#")]),t._v(" sendfile(linux2.4+)")]),t._v(" "),e("p",[t._v("2次上下文切换+0次拷贝\n"),e("img",{attrs:{src:r(445),alt:""}})]),t._v(" "),e("h4",{attrs:{id:"rocketmq储存方式-采用mmap-还有一步-页缓存到socket-buffer的拷贝"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rocketmq储存方式-采用mmap-还有一步-页缓存到socket-buffer的拷贝"}},[t._v("#")]),t._v(" rocketMQ储存方式(采用mmap,还有一步:页缓存到socket buffer的拷贝)")]),t._v(" "),e("ul",[e("li",[t._v("采用Topic混合追加方式，即一个 CommitLog 文件中会包含分给此 Broker 的所有消息，不论消息属于哪个 Topic 的哪个 Queue 。")]),t._v(" "),e("li",[t._v("消息顺序写入,追加到commitLog中")]),t._v(" "),e("li",[t._v("建立消息对应的consumerQueue,存储对应的物理地址,相当于索引")])]),t._v(" "),e("p",[t._v("rocketmq做了一些优化:")]),t._v(" "),e("ol",[e("li",[t._v("文件预分配,会提前准备好下一个文件的分配，防止在消息写入的过程中分配文件，产生抖动。")]),t._v(" "),e("li",[t._v("文件预热,减少大文件 mmap 因为缺页中断产生的性能问题")])]),t._v(" "),e("p",[e("strong",[t._v("Summary")])]),t._v(" "),e("ol",[e("li",[t._v("顺序写盘，整体来看是顺序读盘，并且使用了 mmap代替read()，不是真正的零拷贝")]),t._v(" "),e("li",[t._v("由于页缓存不稳定性和mmap惰性加载(缺页中断才真正加载数据),用文件预先分配和文件预热优化")])]),t._v(" "),e("h4",{attrs:{id:"kafka储存方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#kafka储存方式"}},[t._v("#")]),t._v(" Kafka储存方式")]),t._v(" "),e("ul",[e("li",[t._v("一个分区一个文件,迁移复制灵活(易扩展),但数量多会增加切换成本")]),t._v(" "),e("li",[t._v("Kafka 的消息写入对于单分区来说也是顺序写，如果分区不多的话从整体上看也算顺序写")]),t._v(" "),e("li",[t._v("发消息 Kafka 用到了零拷贝(代码调用FileChannel.transferTo,底层就是 sendfile)")])])])}),[],!1,null,null,null);a.default=s.exports}}]);